#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------
# title            : eShell
# description      : Elasticsearch API available via Python interactive shell.
# author           : Patryk Krawaczyński
# update date      : 22.10.2017
# version          : 0.5.6.3
# license          : Apache License (2.0)
# usage            : ./eshell [es master ip | es master hostname]
# python version   : 3.5.3
# required modules : requests 2.18.4 (http://docs.python-requests.org/en/master/)
#                  : elasticsearch 5.4.0 (http://elasticsearch-py.readthedocs.org/en/master/)
# notes            : https://github.com/nfsec/eshell
# -----------------

import cmd
import os
import re
import socket
import subprocess
import sys
import json
import elasticsearch
import requests
import readline
import operator
import traceback


# Helpers
def error(message):
    """
    Print error message and exit with status 2.
    """
    print("Error: {0}".format(message))
    sys.exit(2)


def check_ip(ip):
    """
    Check if IP address is valid one.
    """
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        return False


def check_hostname(hostname):
    """
    Check if DNS address is valid one.
    """
    try:
        socket.gethostbyname(hostname)
        return True
    except socket.error:
        return False


def less(text):
    try:
        pager = subprocess.Popen(["less", "-F", "-R", "-S", "-X", "-K", "-N"], stdin=subprocess.PIPE, stdout=sys.stdout)
        for line in text:
            pager.stdin.write(line.encode("utf-8"))
        pager.stdin.close()
        pager.wait()
    except IOError:
        print("Exiting...")
    except KeyboardInterrupt:
        print("Exiting...")


def isopen(ip, port):
    """
    Check if IP address have open port.
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1)
    try:
        s.connect((ip, port))
        s.settimeout(None)
        s.shutdown(2)
        print("Connected to: {0} on port: {1}".format(str(ip), str(port)))
        return True
    except socket.error as e:
        print("Problem with connection to: {0} on port: {1}. Error code:".format(str(ip), str(port)), e)
        return False


def commandlist(subcommand):
    commands = []
    for i in dir(subcommand):
        if i.startswith("do_"):
            commands.append(i.replace("do_", ""))
    return commands


def pretty_print(dictionary, indent=0):
    """
    Pretty print all the complexities.
    """
    for k, v in sorted(dictionary.items()):
        if type(v) == dict:
            if len(v) == 0:
                print(" " * indent, str(k) + ": {empty}")
            else:
                print(" " * indent, str(k) + ": ")
                pretty_print(v, indent + len(k) + 1)
        elif type(v) == list:
            if len(v) == 0:
                print(" " * indent, str(k) + ": [empty]")
            elif type(v[0]) == dict:
                print(" " * indent, str(k) + ": ")
                for x in v:
                    pretty_print(x, indent + len(k) + 1)
            else:
                print(" " * indent, str(k) + ": " + str.join(", ", v))
        else:
            print(" " * indent, str(k) + ": " + str(v))


# Autocomplete functions
def indexlist():
    indices = []
    for i in es.cat.indices(h="index").split("\n"):
        if i:
            indices.append(i.replace(" ", ""))
    return indices


def nodelist():
    nodes = []
    for i in es.cat.nodes(h="name").split("\n"):
        if i:
            nodes.append(i)
    return nodes


# Colors for terminal
class BColors:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


# Elasticsearch console
class ES(cmd.Cmd):
    intro = "{0}\n### Welcome to Elastic Shell console!\n### For more information, type \"help\" or \"?\".\n{1}".format(
        BColors.BOLD, BColors.ENDC)
    prompt = "es:~$ "
    ruler = "-"
    doc_header = "Available commands (type: help <command>):"

    def default(self, line):
        """
        Called on an input line when the command prefix is not recognized.
        In that case we execute the line as Python code.
        """
        try:
            exec(line) in self._locals, self._globals
        except NameError:
            print("Command {0} not found.".format(line))
        except SyntaxError:
            print("Command not found or invalid syntax.")
        except KeyboardInterrupt:
            print("Detected Ctrl+D. Exiting...")
        except Exception as e:
            print("{0} : {1}".format(e.__class__, e))

    def preloop(self):
        """
        Initialization before prompting user for commands.
        """
        cmd.Cmd.preloop(self)
        self._history = []
        self._locals = {}
        self._globals = {}

    def precmd(self, line):
        """
        This method is called after the line has been input but before
        it has been interpreted. If you want to modifdy the input line
        before execution (for example, variable substitution) do it here.
        """
        self._history += [line.strip()]
        return line

    def postloop(self):
        """
        Take care of any unfinished business.
        """
        cmd.Cmd.postloop(self)
        print("Exiting...")

    def postcmd(self, stop, line):
        """
        If you want to stop the console, return something that evaluates to true.
        If you want to do some post command processing, do it here.
        """
        return stop

    def emptyline(self):
        """
        Do nothing on empty line input.
        """
        pass

    def do_prompt(self, args):
        """
        Change console prompt.
        $ prompt [new prompt] - set new prompt.
        """
        self.prompt = "{0}:~$ ".format(args)

    def do_help(self, args):
        """
        Get help on commands:
        'help' or '?' with no arguments prints a list of commands for which help is available
        'help <command>' or '? <command>' gives help on <command>
        """
        cmd.Cmd.do_help(self, args)

    def do_history(self, args):
        """
        Print a list of commands that have been entered into console.
        """
        print(self._history)

    def do_clear(self, args):
        """
        Clear the screen.
        """
        os.system("clear")

    def do_shell(self, line):
        """
        Pass command to a system shell when line begins with '!'
        """
        print("Running shell command: {0}\n".format(line))
        sub_cmd = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE)
        output = sub_cmd.communicate()[0].decode("utf-8")
        print(output)
        self.last_output = output

    def do_echo(self, line):
        """
        Print the input, replacing '$out' with the output of the last shell command.
        """
        print(line.replace("$out", self.last_output))

    def do_quit(self, args):
        """
        Quits from the console.
        """
        print("Quitting...")
        sys.exit(0)

    def do_exit(self, args):
        """
        Exits from the console.
        """
        print("Exiting...")
        sys.exit(0)

    def do_EOF(self, line):
        """
        Exit on system end of file character (Ctrl+D).
        """
        return True

    def do_show(self, args):
        """
        Enter to cluster information submenu.
        """
        show_cli = Show()
        show_cli.cmdloop()

    def do_exec(self, args):
        """
        Enter to cluster execution submenu.
        """
        exec_cli = Exec()
        exec_cli.cmdloop()


class Show(cmd.Cmd):
    intro = "\n{0}### Entering to cluster information menu!\n### For more information, type \"help\" or \"?\".\n{1}". \
        format(BColors.BOLD, BColors.ENDC)
    prompt = "es:show~$ "
    ruler = "-"
    doc_header = "Available commands (type: help <command>):"

    def default(self, line):
        """
        Called on an input line when the command prefix is not recognized.
        In that case we execute the line as Python code.
        """
        try:
            exec(line) in self._locals, self._globals
        except NameError:
            print("Command {0} not found.".format(line))
        except SyntaxError:
            print("Command not found or invalid syntax.")
        except KeyboardInterrupt:
            print("Detected Ctrl+D. Exiting...")
        except Exception as e:
            print("{0} : {1}".format(e.__class__, e))

    def preloop(self):
        """
        Initialization before prompting user for commands.
        """
        cmd.Cmd.preloop(self)
        self._history = []
        self._locals = {}
        self._globals = {}

    def precmd(self, line):
        """
        This method is called after the line has been input but before
        it has been interpreted. If you want to modifdy the input line
        before execution (for example, variable substitution) do it here.
        """
        self._history += [line.strip()]
        return line

    def postloop(self):
        """
        Take care of any unfinished business.
        """
        cmd.Cmd.postloop(self)
        print("Exiting...")

    def postcmd(self, stop, line):
        """
        If you want to stop the console, return something that evaluates to true.
        If you want to do some post command processing, do it here.
        """
        return stop

    def emptyline(self):
        """
        Do nothing on empty line input.
        """
        pass

    def do_prompt(self, args):
        """
        Change console prompt.
        $ prompt [new prompt] - set new prompt.
        """
        self.prompt = "{0}:~$ ".format(args)

    def do_help(self, args):
        """
        Get help on commands:
        'help' or '?' with no arguments prints a list of commands for which help is available
        'help <command>' or '? <command>' gives help on <command>
        """
        cmd.Cmd.do_help(self, args)

    def do_history(self, args):
        """
        Print a list of commands that have been entered into console.
        """
        print(self._history)

    def do_clear(self, args):
        """
        Clear the screen.
        """
        os.system("clear")

    def do_shell(self, line):
        """
        Pass command to a system shell when line begins with '!'
        """
        print("Running shell command: {0}\n".format(line))
        sub_cmd = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE)
        output = sub_cmd.communicate()[0].decode("utf-8")
        print(output)
        self.last_output = output

    def do_echo(self, line):
        """
        Print the input, replacing '$out' with the output of the last shell command.
        """
        print(line.replace("$out", self.last_output))

    def do_quit(self, args):
        """
        Quits from the console.
        """
        print("Quitting...")
        sys.exit(0)

    def do_exit(self, args):
        """
        Exits from the console.
        """
        print("Exiting...")
        sys.exit(0)

    def do_EOF(self, line):
        """
        Exit on system end of file character (Ctrl+D).
        """
        return True

    def do_leave(self, line):
        """
        Leave submenu.
        """
        return True

    def do_exec(self, line):
        """
        Execute command in cluster execution menu.
        """
        Exec().onecmd(line)

    def complete_exec(self, text, line, begidx, endidx):
        return [i for i in commandlist(Exec()) if i.startswith(text)]

    # Elasticsearch cluster
    def do_cluster_allocation(self, args):
        """
        The purpose of the cluster allocation explain API is to provide explanations for shard allocations in the
        cluster. For unassigned shards, the explain API provides an explanation for why the shard is unassigned.
        $ cluster_allocation - explain the first unassigned shard.
        $ cluster_allocation [index] [shard_id] [true] - specify the index and shard id of the shard you would like an
          explanation for, as well as the primary flag to indicate whether to explain the primary shard for the given
          shard id or one of its replica shards. These three request parameters are required.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please provide index name, shard id and true or false if primary.")
                print()
            else:
                try:
                    showme = '{{ "index": "{0}", "shard": {1}, "primary": {2} }}'.format(str(parms[0]), str(parms[1]),
                                                                                         str(parms[2]))
                    print()
                    pretty_print(es.cluster.allocation_explain(body=showme), indent=2)
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.cluster.allocation_explain(include_disk_info=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def do_cluster_repositories(self, args):
        """
        The repositories command shows the snapshot repositories registered in the cluster.
        """
        try:
            print()
            print(es.cat.repositories(v=True, s="id"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_cluster_snapshots(self, args):
        """
        The cluster_snapshots command shows all snapshots that belong to a specific repository.
        $ cluster_snapshots [repository_name] - show information about each snapshot in repository.
        """
        if args:
            try:
                print()
                print(es.cat.snapshots(repository=args, ignore_unavailable=True, v=True, s="id"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please provide name of repository to show its snapshots. ")
            print("To find a list of available repositories to query, the command 'cluster_repositories' can be used.")
            print()

    def do_cluster_ping(self, args):
        """
        Returns 'UP' if the cluster is up, 'DOWN' otherwise.
        """
        try:
            if es.ping():
                print("\nUP!\n")
            else:
                print("\nDOWN!\n")
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_cluster_info(self, args):
        """
        Get the basic info from the current cluster.
        """
        try:
            print()
            pretty_print(es.info(), indent=2)
            print()
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_cluster_master(self, args):
        """
        Displays the master’s node ID, bound IP address, and node name.
        """
        try:
            print()
            print(es.cat.master(v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_cluster_health(self, args):
        """
        Get a very simple status on the health of the cluster.
        $ cluster_health - show cluster health.
        $ cluster_health table - one-line representation of the same information from cluster_health.
        """
        try:
            if args == "table":
                print()
                print(es.cat.health(v=True))
            else:
                print()
                pretty_print(es.cluster.health(level="cluster"), indent=2)
                print()
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_cluster_tasks(self, args):
        """
        Show all pending cluster tasks which have not yet been executed.
        $ cluster_tasks urgent - show urgent tasks.
        $ cluster_tasks high - show high tasks.
        $ cluster_tasks normal - show normarl tasks.
        $ cluster_tasks - show all tasks (default).
        """
        try:
            task_list = es.cat.pending_tasks(v=True)
            if args in ["urgent", "high", "normal"]:
                print()
                print(task_list.split("\n")[0])
                for line in task_list.split("\n"):
                    if args.upper() in line:
                        print(line)
                print()
            else:
                print()
                less(es.cat.pending_tasks())
                print()
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_cluster_tasks_stats(self, args):
        """Show cluster tasks statistics."""
        task_list = requests.get("{0}/_cat/pending_tasks?v=True".format(host))
        ustats = re.compile("URGENT")
        umatch = ustats.findall(task_list.content.decode("utf-8"))
        hstats = re.compile("HIGH")
        hmatch = hstats.findall(task_list.content.decode("utf-8"))
        nstats = re.compile("NORMAL")
        nmatch = nstats.findall(task_list.content.decode("utf-8"))
        print("Tasks statistics: URGENT: {0} HIGH: {1} NORMAL: {2}".format(str(len(umatch)), str(len(hmatch)), str(
            len(nmatch))))

    def do_cluster_settings(self, args):
        """
        Get current cluster settings.
        $ cluster_settings with_defaults - get cluster default settings.
        $ cluster_settings - get cluster custom settings (default).
        """
        try:
            if args == "with_defaults":
                print()
                pretty_print(es.cluster.get_settings(flat_settings=True, include_defaults=True), indent=2)
                print()
            else:
                print()
                pretty_print(es.cluster.get_settings(flat_settings=True), indent=2)
                print()
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_cluster_stats(self, args):
        """
        The Cluster stats allows to retrieve statistics from a cluster wide perspective.
        """
        try:
            print()
            pretty = es.cluster.stats(human=True)
            print("cluster_name: {0}".format(str(pretty["cluster_name"])))
            print("status: {0}".format(str(pretty["status"])))
            print("timestamp: {0}".format(str(pretty["timestamp"])))
            print("_nodes")
            pretty_print(pretty["_nodes"], indent=7)
            print("nodes:")
            pretty_print(pretty["nodes"], indent=6)
            print("indices:")
            pretty_print(pretty["indices"], indent=8)
            print()
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_cluster_version(self, args):
        """
        Shows the cluster state version.
        """
        try:
            print()
            pretty = es.cluster.state(metric="version", flat_settings=True)
            pretty_print(pretty, indent=2)
            print()
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_cluster_nodes(self, args):
        """
        Shows the cluster nodes part of the response.
        """
        try:
            print()
            pretty = es.cluster.state(metric="nodes", flat_settings=True)
            pretty_print(pretty, indent=2)
            print()
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_cluster_blocks(self, args):
        """
        Shows the cluster blocks part of the response.
        """
        try:
            print()
            pretty = es.cluster.state(metric="blocks", flat_settings=True)
            pretty_print(pretty, indent=2)
            print()
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    # Elasticsearch indices
    def do_indices_field_stats(self, args):
        """
        The field stats api allows one to find statistical properties of a field without executing a search,
        but looking up measurements that are natively available in the Lucene index.
        $ indices_field_stats [index] [field] [cluster|indices] - show <field> stats for the <index> on <cluster>
          level.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter index name, field name and level (indices / cluster).")
                print()
            else:
                try:
                    print()
                    print(json.dumps(es.field_stats(index=parms[0], fields=parms[1], level=parms[2]), indent=2))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Invalid number of arguments. Please enter index name and field name. (indices / cluster)")
            print()

    def do_indices_templates(self, args):
        """
        The indices_templates command provides information about existing indices templates.
        $ indices_templates [template_name] - show template information in json format.
        $ indices_templates - show all templates for indices.
        """
        if args:
            try:
                print()
                print(json.dumps(es.indices.get_template(name=args), indent=4))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.cat.templates(v=True, s="name"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def do_indices_mapping(self, args):
        """
        Retrieve mapping definition of index or index/type.
        $ indices_mapping [index] - show <index> mapping.
        """
        if args:
            try:
                print()
                pretty = es.indices.get_mapping(index=args)
                print(json.dumps(pretty, indent=4))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print("Please provide index name.")

    def complete_indices_mapping(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_field_mapping(self, args):
        """
        Retrieve mapping definition of a specific field.
        $ indices_field_mapping [field] [index] - show <field> mapping in <index>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter field and index name.")
                print()
            else:
                try:
                    print()
                    print(es.indices.get_field_mapping(fields=parms[0], index=parms[1]))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Invalid number of arguments. Please enter field and index name.")
            print()

    def do_indices_stats_docs(self, args):
        """
        The number of docs / deleted docs (docs not yet merged out). Note, affected by refreshing the index.
        $ indices_stats_docs [index] - show number of docs for <index>.
        $ indices_stats_docs - show number of docs for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="docs", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="docs", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_docs(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_store(self, args):
        """
        Show the size of the indices.
        $ indices_stats_store [index] - show size of <index>.
        $ indices_stats_store - show size of all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="store", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="store", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_store(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_indexing(self, args):
        """
        Show indexing statistics.
        $ indices_stats_indexing [index] - show indexing stats for <index>.
        $ indices_stats_indexing - show indexing stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="indexing", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="indexing", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_indexing(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_get(self, args):
        """
        Get statistics, including missing stats.
        $ indices_stats_get [index] - show get stats for <index>.
        $ indices_stats_get - show get stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="get", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="get", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_get(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_search(self, args):
        """
        Search statistics including suggest statistics.
        $ indices_stats_search [index] - show search stats for <index>.
        $ indices_stats_search - show search stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="search", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="search", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_search(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_segments(self, args):
        """
        Retrieve the memory use of the open segments.
        $ indices_stats_segments [index] - show open segments stats for <index>.
        $ indices_stats_segments - show open segments stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="segments", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="segments", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_segments(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_completion(self, args):
        """
        Show completion suggest statistics.
        $ indices_stats_completion [index] - show completion suggest stats for <index>.
        $ indices_stats_completion - show completion suggest stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="completion", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="completion", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_completion(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_fielddata(self, args):
        """
        Show fielddata statistics.
        $ indices_stats_fielddata [index] - show fielddata stats for <index>.
        $ indices_stats_fielddata - show fielddata stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="fielddata", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="fielddata", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_fielddata(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_flush(self, args):
        """
        Show flush statistics.
        $ indices_stats_flush [index] - show flush stats for <index>.
        $ indices_stats_flush - show flush stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="flush", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="flush", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_flush(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_merge(self, args):
        """
        Show merge statistics.
        $ indices_stats_merge [index] - show merge stats for <index>.
        $ indices_stats_merge - show merge stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="merge", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="merge", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_merge(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_request_cache(self, args):
        """
        Show request cache statistics.
        $ indices_stats_request_cache [index] - show request cache stats for <index>.
        $ indices_stats_request_cache - show request cache stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="request_cache", human=True),
                             indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="request_cache", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_request_cache(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_refresh(self, args):
        """
        Show refresh statistics.
        $ indices_stats_refresh [index] - show refresh stats for <index>.
        $ indices_stats_refresh - show refresh stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="refresh", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="refresh", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_refresh(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_warmer(self, args):
        """
        Show warmer statistics.
        $ indices_stats_warmer [index] - show warmer stats for <index>.
        $ indices_stats_warmer - show warmer stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="warmer", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="warmer", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_warmer(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_translog(self, args):
        """
        Show translog statistics.
        $ indices_stats_translog [index] - show translog stats for <index>.
        $ indices_stats_translog - show translog stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="translog", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="translog", human=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_stats_translog(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_size(self, args):
        """
        Show indices size statistics.
        """
        try:
            index_list = es.cat.indices(h="index,pri.store.size", bytes="b")
            index_temp = []
            for text_line in index_list.split():
                index_temp.append(text_line)
            index_dict = dict(index_temp[i:i + 2] for i in range(0, len(index_temp), 2))
            index_dict = {str(k): int(v) for k, v in index_dict.items()}
            index_sort = sorted(index_dict.items(), key=operator.itemgetter(1))
            almost_1mb = []
            almost_10mb = []
            almost_100mb = []
            almost_1gb = []
            almost_10gb = []
            almost_100gb = []
            almost_other = []
            for item in index_sort:
                if item[1] <= 1000000:
                    almost_1mb.append(item)
                elif item[1] <= 10000000:
                    almost_10mb.append(item)
                elif item[1] <= 100000000:
                    almost_100mb.append(item)
                elif item[1] <= 1000000000:
                    almost_1gb.append(item)
                elif item[1] <= 10000000000:
                    almost_10gb.append(item)
                elif item[1] <= 100000000000:
                    almost_100gb.append(item)
                elif item[1] >= 100000000000:
                    almost_other.append(item)
            print()
            print(
                "i <= 1.MB: {0} | i <= 10.MB: {1} | i <= 100.MB: {2} | i <= 1.GB: {3} | i <= 10.GB: {4} | i <= 100.GB: {5} | i >= 100.GB: {6}".format(
                    str(len(almost_1mb)), str(
                        len(almost_10mb)), str(len(almost_100mb)), str(
                        len(almost_1gb)), str(len(almost_10gb)), str(
                        len(almost_100gb)), str(len(almost_other))))
            print()
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_indices_settings(self, args):
        """
        Retrieve settings for one or more (or all) indices.
        - indices_settings [index] - show settings for <index>.
        - indices_settings - show settings for all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.indices.get_settings(index=args, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.indices.get_settings(flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_settings(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_status(self, args):
        """
        Show indices state statistics.
        """
        try:
            index_list = es.cat.indices(v=True, h="health")
            rstats = re.compile("red")
            rmatch = rstats.findall(index_list)
            ystats = re.compile("yellow")
            ymatch = ystats.findall(index_list)
            gstats = re.compile("green")
            gmatch = gstats.findall(index_list)
            print("Indices states: RED: {0} YELLOW: {1} GREEN: {2}".format(str(len(rmatch)), str(len(ymatch)), str(
                len(gmatch))))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_indices_exists(self, args):
        """
        Return a information indicating whether given index exists.
        $ indices_exists [index] - a name of index to check (default).
        """
        if args:
            print()
            try:
                if es.indices.exists(index=args):
                    print("{0} exists.".format(args))
                    print()
                else:
                    print("{0} don't exists".format(args))
                    print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("No indices specified.")
            print()

    def complete_indices_exists(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_segments(self, args):
        """
        The segments command is the detailed view of Lucene segments per index.
        $ indices_segments [index] - show segments of the index.
        $ indices_segments  - show segments of all indices (default).
        """
        if args:
            try:
                print()
                less(es.cat.segments(index=args, v=True, s="index"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                less(es.cat.segments(v=True, s="index"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_segments(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_metadata(self, args):
        """
        Shows the indices metadata part of the response.
        If you supply a comma separated list of indices, the returned
        output will only contain the indices listed.
        $ indices_metadata [index] - show metadata of <index>.
        $ indices_metadata - show metadata of all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.state(metric="metadata", index=args, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.cluster.state(metric="metadata", flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_metadata(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices(self, args):
        """
         The indices command provides a cross-section of each index.
         $ indices [index] - show information about <index>.
         $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                less(es.cat.indices(s="index", v=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_green(self, args):
        """
        The indices_green command provides a cross-section of each index in green health status.
        $ indices [index] - show information about <index>.
        $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args, health="green"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.cat.indices(s="index", v=True, health="green"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_green(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_yellow(self, args):
        """
        The indices_yellow command provides a cross-section of each index in yellow health status.
        $ indices [index] - show information about <index>.
        $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args, health="yellow"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.cat.indices(s="index", v=True, health="yellow"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_yellow(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_red(self, args):
        """
        The indices_red command provides a cross-section of each index in red health status.
        $ indices [index] - show information about <index>.
        $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args, health="red"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.cat.indices(s="index", v=True, health="red"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_red(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_aliases(self, args):
        """
        Shows information about currently configured aliases to indices including filter and routing infos.
        $ indices_aliases [alias] - <alias> name to return from aliases.
        $ indices_aliases - show all aliases (default).
        """
        if args:
            try:
                print()
                print(es.cat.aliases(name=args, v=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.cat.aliases(s="alias", v=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def do_indices_documents(self, args):
        """
        Count provides quick access to the document count of the entire cluster, or individual indices.
        The document count indicates the number of live documents and does not include deleted documents
        which have not yet been cleaned up by the merge process.
        $ indices_documents [index] - document count in <index>.
        $ indices_documents - document count for all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.count(index=args, v=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.cat.count(v=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_documents(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_routing_table(self, args):
        """
        Shows the indices routing_table part of the response.
        If you supply a comma separated list of indices, the returned
        output will only contain the indices listed.
        $ indices_routing_table [index] - show routing_table of <index>.
        $ indices_routing_table - show routing_table of all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.state(metric="routing_table", index=args, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.cluster.state(metric="routing_table", flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_routing_table(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_health(self, args):
        """
        Get a very simple status on the health of the indices.
        $ indices_health [index] - show health of <index>.
        $ indices_health - show health of all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.health(level="indices", index=args), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.cluster.health(level="indices"), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_health(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    # Elasticsearch shards
    def do_shards(self, args):
        """
        The shards command is the detailed view of what nodes contain which shards.
        $ shards [index] - show shards of <index>.
        $ shards - show shards of all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.shards(index=args, v=True, s="node"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                less(es.cat.shards(v=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_shards(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_store(self, args):
        """
        Provides store information for shard copies of indices. Store information reports on which
        nodes shards copies exist, the shard copy version, indicating how recent the are, and any
        exceptions encountered while opening the shard index or from earlier engine failure.
        $ shards_store [index] [red|yellow|green] - show shards store information about <index>.
        $ shards_store - show shards store information about all indices.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and its status.")
                print()
            else:
                try:
                    print()
                    print(json.dumps(es.indices.shard_stores(index=parms[0], status=parms[1]), indent=4))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            try:
                print()
                print(json.dumps(es.indices.shard_stores(index="_all", status="all"), indent=4))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_shards_store(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_unassigned(self, args):
        """
        List unassigned shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "UNASSIGNED" in line:
                print(line)
        print()

    def do_shards_relocating(self, args):
        """
        List relocating shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "RELOCATING" in line:
                print(line)
        print()

    def do_shards_initializing(self, args):
        """
        List initializing shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "INITIALIZING" in line:
                print(line)
        print()

    def do_shards_started(self, args):
        """
        List started shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "STARTED" in line:
                print(line)
        print()

    def do_shards_recovery(self, args):
        """
        Recovery is a view of shard replication.
        $ shards_recovery [index] - show recovery status of the <index>.
        $ shards_recovery - show recovery status of all indices (default).

          index                  | idx | index name
          shard                  | sh  | shard name
          time                   | ti  | recovery time
          type                   | ty    | recovery type
          stage                  | st    | recovery stage
          source_host            | shost | source host
          source_node            | snode | source node name
          target_host            | thost | target host
          target_node            | tnode | target node name
          repository             | rep   | repository
          snapshot               | snap  | snapshot
          files                  | f     | number of files to recover
          files_recovered        | fr    | files recovered
          files_percent          | fp    | percent of files recovered
          files_total            | tf    | total number of files
          bytes                  | b     | number of bytes to recover
          bytes_recovered        | br    | bytes recovered
          bytes_percent          | bp    | percent of bytes recovered
          bytes_total            | tb    | total number of bytes
          translog_ops           | to    | number of translog ops to recover
          translog_ops_recovered | tor   | translog ops recovered
          translog_ops_percent   | top   | percent of translog ops recovered
        """
        if args:
            try:
                print()
                print(es.cat.recovery(index=args, v=True, s="index",
                                      h="idx,sh,ti,ty,st,shost,snode,thost,tnode,rep,snap,f,fr,fp,tf,b,br,bp,tb,to,tor,top"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                less(es.cat.recovery(v=True, s="index",
                                     h="idx,sh,ti,ty,st,shost,snode,thost,tnode,rep,snap,f,fr,fp,tf,b,br,bp,tb,to,tor,top"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_shards_recovery(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_health(self, args):
        """
        Get a very simple status on the health of the indices shards.
        $ indices_health [index] - show health of index <shards>.
        $ indices_health - show health of shards in all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.health(level="shards", index=args), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.cluster.health(level="shards"), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_shards_health(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    # Elasticsearch nodes
    def do_nodes_plugins(self, args):
        """
        The plugins command provides a view per nodes of running plugins.
        """
        try:
            print()
            print(es.cat.plugins(v=True, s="name"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_settings(self, args):
        """
        Retrieves information about node(s) settings in the cluster.
        $ nodes_settings [node_id|name] - show <node> settings.
        $ node_settings - show all the nodes settings in the cluster (default).
          - build_hash - sort of the last git commit in this release.
          - host - the node's host name.
          - http_address - host and port where primary HTTP connections are accepted.
          - ip - the node's ip address.
          - name - the nodes name.
          - transport_address - host and port where transport HTTP connections are accepted.
          - version - elasticsearch version running on this node.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="settings", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="settings", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_settings(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_os(self, args):
        """
        Retrieve node(s) information that concern the operating system.
        $ nodes_info_os [node_id|name] - show node os information.
        $ nodes_info_os - show os information for all the nodes (default).
          - os.refresh_interval_in_millis - refresh interval for the OS statistics.
          - os.name - name of the operating system (Linux / Windows / Mac OS X).
          - os.arch - name of the JVM architecture (amd64, x86).
          - os.version - version of the operating system.
          - os.available_processors - number of processors available to the Java virtual machine.
          - os.allocated_processors - the number of processors actually used to calculate thread
            pool size. This number can be set with the "processors" setting of a node and defaults
            to the number of processors reported by the OS. In both cases this number will never be
            larger than 32.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="os", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="os", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_info_os(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_process(self, args):
        """
        Retrieve node(s) information that concern the current running ElasticSearch process.
        $ node_info_process [node_id|name] - show node ES process information.
        $ node_info_process - show ES process information for all the nodes (default).
          - process.refresh_intervel_in_millis - refresh interval for the process statistics.
          - process.id - process identifier (PID).
          - process.mlockall - indicates if the process address space has been successfully locked in memory.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="process", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="process", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_info_process(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_jvm(self, args):
        """
        # TODO
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="jvm", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="jvm", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_info_jvm(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_thread_pool(self, args):
        """
        # TODO
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="thread_pool", human=True, flat_settings=True),
                             indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="thread_pool", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_info_thread_pool(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_transport(self, args):
        """
        # TODO
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="transport", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="transport", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_info_transport(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_http(self, args):
        """
        # TODO
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="http", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="http", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_info_http(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_plugins(self, args):
        """
        Result will contain details about the loaded plugins per node.
        $ node_info_plugins [node_id|name] - show <node> ES plugins information.
        $ node_info_plugins - show ES plugins information for all the nodes (default).
          - plugins.name - plugin name.
          - plugins.description - plugin description if any.
          - plugins.site - true if the plugin is a site plugin.
          - plugins.jvm - true if plugin is a plugin running in the JVM.
          - plugins.url - URL if the plugin is a site plugin.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="plugins", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="plugins", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_info_plugins(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_ingest(self, args):
        """
        Result will contain details about the available processors per node.
        $ node_info_ingest [node_id|name] - show <node> ES ingest information.
        $ node_info_ingest - show ES ingest information for all the nodes (default).
          - processors.type - the processor type.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="ingest", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="ingest", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_info_ingest(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_indexing_buffer(self, args):
        """
        Result will contain details about heap used for indexing process.
        $ node_info_indexing_buffer [node_id|name] - show <node> ES indexing heap information.
        $ node_info_indexing_buffer - show ES indexing heap information for all the nodes (default).
          - total_indexing_buffer - total heap allowed to be used to hold recently indexed documents before
            they must be written do disk. This size is a shared pool across all shards on this node, and is
            controlled by Indexing Buffer settings (indices.memory.index_buffer_size).
          - total_indexing_buffer_in_bytes - same as total_indexing_buffer but expressed in bytes.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="indices", human=True, flat_settings=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="indices", human=True, flat_settings=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_info_indexing_buffer(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_indices(self, args):
        """
        Show indices stats about size, document count, indexing and deletion times, search times,
        field cache size, merges and flushes.
        $ node_stats_indices [node_id|name] - show node ES indices stats.
        $ node_stats_indices - show ES indices stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="indices", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="indices", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_indices(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_fs(self, args):
        """
        Show file system information, data path, free disk space, read/write stats.
        $ nodes_stats_fs [node_id|name] - show <node> ES fs stats.
        $ nodes_stats_fs - show node ES fs stats for all the nodes (default).
          - fs.timestamp - last time the file stores statistics have been refreshed.
          - fs.total.total_in_bytes - total size (in bytes) of all file stores.
          - fs.total.free_in_bytes - total number of unallocated bytes in all file stores.
          - fs.total.available_in_bytes - total number of bytes available to this Java virtual machine on all
            file stores.
          - fs.data - list of all file stores.
          - fs.data.path - path to the file store.
          - fs.data.mount - mount point of the file store (ex: /dev/sda2)
          - fs.data.type - type of the file store (ex: ext4)
          - fs.data.total_in_bytes - total size (in bytes) of the file store.
          - fs.data.free_in_bytes - total number of unallocated bytes in the file store.
          - fs.data.available_in_bytes - total number of bytes available to this Java virtual machine on this
            file store.
          - fs.data.spins - indicates if the store is backed by spinning storage.
            null means we cloud not determine it.
            true means the device possible spins.
            false means it does not (ex: solid-state disk)
          - fs.io_stats.devices - array of disk metrics for each device that is backing an Elasticsearch data path.
            These disk metrics are probed periodically and averages between the last probe and the current probe are
            computed.
          - fs.io_stats.devices.device_name - the Linux device name.
          - fs.io_stats.devices.operations - the total number of read and write operations for the device completed
            since starting Elasticsearch.
          - fs.io_stats.devices.read_operations - the total number of read operations for the device completed since
            starting Elasticsearch.
          - fs.io_stats.devices.write_operations - the total number of write operations for the device completed since
            starting Elasticsearch.
          - fs.io_stats.devices.read_kilobytes - the total number of kilobytes read for the device since starting
            Elasticsearch.
          - fs.io_stats.devices.write_kilobytes - the total number of kilobytes written for the device since starting
            Elasticsearch.
          - fs.io_stats.operations - the total number of read and write operations across all devices used by
            Elasticsearch completed since starting Elasticsearch.
          - fs.io_stats.read_operations - the total number of read operations for across all devices used by
            Elasticsearch completed since starting Elasticsearch.
          - fs.io_stats.write_operations - the total number of write operations across all devices used by
            Elasticsearch completed since starting Elasticsearch.
          - fs.io_stats.read_kilobytes - the total number of kilobytes read across all devices used by Elasticsearch
            since starting Elasticsearch.
          - fs.io_stats.write_kilobytes - the total number of kilobytes written across all devices used by Elasticsearch
            since starting Elasticsearch.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="fs", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="fs", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_fs(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_http(self, args):
        """
        Show HTTP connection information.
        $ node_stats_http [node_id|name] - show <node> ES HTTP stats.
        $ node_stats_http - show ES HTTP stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="http", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="http", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_http(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_jvm(self, args):
        """
        Show JVM stats, memory pool information, garbage collection, buffer pools, number of loaded/unloaded classes.
        $ node_stats_jvm [node_id|name] - show node ES JVM stats.
        $ node_stats_jvm - show ES JVM stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="jvm", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="jvm", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_jvm(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_os(self, args):
        """
        Show operating system stats, load average, mem, swap.
        $ node_stats_os [node_id|name] - show <node> ES OS stats.
        $ node_stats_os - show ES OS stats for all the nodes (default).
          - os.timestamp - last time the operating system statistics have been refreshed.
          - os.cpu.percent - recent CPU usage for the whole system, or -1 if not supported.
          - os.cpu.load_average.1m - one-minute load average on the system (field is not present if one-minute load
            average is not available).
          - os.cpu.load_average.5m - five-minute load average on the system (field is not present if five-minute
            load average is not available).
          - os.cpu.load_average.15m - fifteen-minute load average on the system (field is not present if fifteen-minute
            load average is not available).
          - os.mem.total_in_bytes - total amount of physical memory in bytes.
          - os.mem.free_in_bytes - amount of free physical memory in bytes.
          - os.mem.free_percent - percentage of free memory.
          - os.mem.used_in_bytes - amount of used physical memory in bytes.
          - os.mem.used_percent - percentage of used memory.
          - os.swap.total_in_bytes - total amount of swap space in bytes.
          - os.swap.free_in_bytes - amount of free swap space in bytes.
          - os.swap.used_in_bytes - amount of used swap space in bytes.
          - os.cgroup.cpuacct.control_group - the cpuacct control group to which the Elasticsearch process belongs.
          - os.cgroup.cpuacct.usage_nanos - the total CPU time (in nanoseconds) consumed by all tasks in the same cgroup
            as the Elasticsearch process.
          - os.cgroup.cpu.control_group - the cpu control group to which the Elasticsearch process belongs.
          - os.cgroup.cpu.cfs_period_micros - the period of time (in microseconds) for how regularly all tasks in the
            same cgroup as the Elasticsearch process should have their access to CPU resources reallocated.
          - os.cgroup.cpu.cfs_quota_micros - the total amount of time (in microseconds) for which all tasks in the same
            cgroup as the Elasticsearch process can run during one period os.cgroup.cpu.cfs_period_micros.
          - os.cgroup.cpu.stat.number_of_elapsed_periods - the number of reporting periods (as specified by
            os.cgroup.cpu.cfs_period_micros) that have elapsed.
          - os.cgroup.cpu.stat.number_of_times_throttled - the number of times all tasks in the same cgroup as
            the Elasticsearch process have been throttled.
          - os.cgroup.cpu.stat.time_throttled_nanos - the total amount of time (in nanoseconds) for which all tasks in
            the same cgroup as the Elasticsearch process have been throttled.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="os", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="os", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_os(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_process(self, args):
        """
        Show process statistics, memory consumption, cpu usage, open file descriptors.
        $ node_stats_process [node_id|name] - show <node> ES process stats.
        $ node_stats_process - show ES process stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="process", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="process", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_process(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_thread_pool(self, args):
        """
        Show statistics about each thread pool, including current size, queue and rejected tasks.
        $ node_stats_thread_pool [node_id|name] - show <node> ES threads stats.
        $ node_stats_thread_pool - show ES threads stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="thread_pool", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="thread_pool", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_thread_pool(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_transport(self, args):
        """
        Show statistics about send and received bytes in cluster communication.
        $ node_stats_transport [node_id|name] - show <node> ES transport stats.
        $ node_stats_transport - show ES transport stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="transport", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="transport", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_transport(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_breaker(self, args):
        """
        Show statistics about the field data circuit breaker.
        $ node_stats_breaker [node_id|name] - show <node> ES breaker stats.
        $ node_stats_breaker - show ES transport stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="breaker", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="breaker", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_breaker(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_discovery(self, args):
        """
        Show statistics about the discovery.
        $ node_stats_discovery [node_id|name] - show <node> ES discovery stats.
        $ node_stats_discovery - show ES discovery stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="discovery", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="discovery", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_discovery(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_ingest(self, args):
        """
        Show statistics about ingest preprocessing.
        $ node_stats_ingest [node_id|name] - show <node> ES ingest stats.
        $ node_stats_ingest - show ES ingest stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="ingest", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="ingest", human=True, level="node"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_stats_ingest(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_allocation(self, args):
        """
        Allocation provides a snapshot of how shards have located around the cluster and the state of disk usage.
        $ nodes_allocation [node_id|name] - show <node> shards allocation.
        $ nodes_allocation - show shards allocation for all the nodes (default).
        """
        if args:
            try:
                print()
                print(es.cat.allocation(node_id=args, v=True))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.cat.allocation(s="node", v=True))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_nodes_allocation(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    do_nodes_disk = do_nodes_allocation

    def do_nodes_cat_disk_space(self, args):
        """
        Shows nodes available disk space.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,disk", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_fielddata(self, args):
        """
        Shows information about currently loaded fielddata on a per-node basis.
        """
        try:
            print()
            print(es.cat.fielddata(s="node", v=True, bytes="mb"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_attributes(self, args):
        """
        Shows custom node attributes.
        """
        try:
            print()
            print(es.cat.nodeattrs(s="node", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_id(self, args):
        """
        Shows nodes uniq ids.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,id", full_id=True, v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_ports(self, args):
        """
        Shows nodes bound ip, transport and http address.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,port,http_address", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_version(self, args):
        """
        Shows nodes Elasticsearch version, build hash and running java version.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,version,build,jdk", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_heap(self, args):
        """
        Shows nodes used and maximum configured heap.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,heap.current,heap.percent,heap.max", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_ram(self, args):
        """
        Shows nodes used and total memory.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,ram.current,ram.percent,ram.max", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_filedesc(self, args):
        """
        Shows nodes used and maximum number of file descriptors.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,file_desc.current,file_desc.percent,file_desc.max", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_load(self, args):
        """
        Shows nodes recent system CPU usage.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,cpu,load_1m,load_5m,load_15m", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_uptime(self, args):
        """
        Shows nodes uptime.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,uptime", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_role(self, args):
        """
        Shows nodes role.
        - m - master eligible node.
        - d - data node.
        - i - ingest node.
        - - - coordinating node only.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,node.role,master", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_completion(self, args):
        """
        Shows nodes size of completion.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,completionSize", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_fielddata_evictions(self, args):
        """
        Shows used fielddata cache memory and evictions.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,fielddataMemory,fielddataEvictions", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_query_cache(self, args):
        """
        Shows used query cache memory and evictions.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,queryCacheMemory,queryCacheEvictions", v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_request_cache(self, args):
        """
        Shows used request cache memory, evictions, hit and miss count.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,requestCacheMemory,requestCacheEvictions,requestCacheHitCount,requestCacheMissCount",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_flush(self, args):
        """
        Shows number of flushes and time spent in flush.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,flushTotal,flushTotalTime",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_get(self, args):
        """
        Shows number of current and total get operations, time spent in gets and others.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,getCurrent,getTime,getTotal,getExistsTime,getExistsTotal,getMissingTime,getMissingTotal",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_delete(self, args):
        """
        Shows number of current and total delete operations, time spent in deletions.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,indexingDeleteCurrent,indexingDeleteTime,indexingDeleteTotal",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_index(self, args):
        """
        Shows number of current and total index operations, time spent in indexing.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,indexingIndexCurrent,indexingIndexTime,indexingIndexTotal,indexingIndexFailed",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_merges(self, args):
        """
        Shows number of current and total mege operations, time spent in merging.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,mergesCurrent,mergesCurrentDocs,mergesCurrentSize,mergesTotal,mergesTotalDocs,mergesTotalSize,mergesTotalTime",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_refresh(self, args):
        """
        Shows number of refreshes and time spent in refreshes.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,refreshTotal,refreshTime",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_script(self, args):
        """
        Shows total script compilations and compiled scripts evicted from cache.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,scriptCompilations,scriptCacheEvictions",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_search(self, args):
        """
        Shows open search contexts.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchOpenContexts",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_search_fetch(self, args):
        """
        Shows current fetch phase operations and time spent in fetch phase.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchFetchCurrent,searchFetchTime,searchFetchTotal",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_search_query(self, args):
        """
        Shows current query phase operations and time spent in query phase.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchQueryCurrent,searchQueryTime,searchQueryTotal",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_search_scroll(self, args):
        """
        Shows current open scroll contexts and time scroll contexts held open.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchScrollCurrent,searchScrollTime,searchScrollTotal",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_segments(self, args):
        """
        Shows number of segments and memory used by segments.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,segmentsCount,segmentsMemory,segmentsIndexWriterMemor,segmentsVersionMapMemory,fixedBitsetMemory",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_cat_suggest(self, args):
        """
        Shows number current suggest operations and time spent in suggest.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,suggestCurrent,suggestTime,suggestTotal",
                               v=True))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_bulk(self, args):
        """
        Show current settings and status of threads for bulk operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="bulk", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_generic(self, args):
        """
        Show current settings and status of threads for generic (e.g., background node discovery) operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="generic", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_index(self, args):
        """
        Show current settings and status of threads for index / delete operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="index", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_search(self, args):
        """
        Show current settings and status of threads for count / search / suggest operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="search", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_get(self, args):
        """
        Show current settings and status of threads for get operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="get", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_percolate(self, args):
        """
        Show current settings and status of threads for percolate operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="percolate", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_snapshot(self, args):
        """
        Show current settings and status of threads for snapshot / restore operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="snapshot", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_warmer(self, args):
        """
        Show current settings and status of threads for segment warm-up operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="warmer", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_refresh(self, args):
        """
        Show current settings and status of threads for refresh operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="refresh", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_listener(self, args):
        """
        Show current settings and status of threads for java client executing action operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="listener", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_management(self, args):
        """
        Show current settings and status of threads management operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="management", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_force_merge(self, args):
        """
        Show current settings and status of threads force merge / optimize operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="force_merge", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_flush(self, args):
        """
        Show current settings and status of threads flush operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="flush", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_fetch_shard_started(self, args):
        """
        Show current settings and status of threads starting shard operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="fetch_shard_started", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_thread_pool_fetch_shard_store(self, args):
        """
        Show current settings and status of threads storing shard operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="fetch_shard_store", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,min,max,keep_alive"))
        except Exception:
            print(format(BColors.FAIL))
            print(traceback.print_exc(limit=1, file=sys.stdout))
            print(format(BColors.ENDC))

    def do_nodes_hot_threads(self, args):
        """
        Shows the current hot threads on each node in the cluster.
        $ nodes_hot_threads [cpu|wait|block] - the type to sample to see hot threads.
        $ nodes_hot_threads - show top 5 hot threads in cpu type.
        """
        if args:
            try:
                print()
                print(es.nodes.hot_threads(threads="5", type=args))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.nodes.hot_threads(threads="5", type="cpu"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def do_nodes_tasks(self, args):
        """
        Show tasks currently executing on one or mode nodes in the cluster.
        $ nodes_tasks [task_id] - show info about particular task.
        $ nodes_tasks - retrieves all tasks currently running on all nodes in the cluster (default).
        """

        if args:
            try:
                print()
                print(json.dumps(es.tasks.get(task_id=args), indent=4))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.cat.tasks(v=True, detailed=True, s="node"))
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))


class Exec(cmd.Cmd):
    intro = "{0}\n### Entering to cluster execution menu!\n### For more information, type \"help\" or \"?\".\n{1}". \
        format(BColors.BOLD, BColors.ENDC)
    prompt = "es:exec~$ "
    ruler = "-"
    doc_header = "Available commands (type: help <command>):"

    def default(self, line):
        """
        Called on an input line when the command prefix is not recognized.
        In that case we execute the line as Python code.
        """
        try:
            exec(line) in self._locals, self._globals
        except NameError:
            print("Command {0} not found.".format(line))
        except SyntaxError:
            print("Invalid command syntax.")
        except KeyboardInterrupt:
            print("Detected Ctrl+D. Exiting...")
        except Exception as e:
            print("{0} : {1}".format(e.__class__, e))

    def preloop(self):
        """
        Initialization before prompting user for commands.
        """
        cmd.Cmd.preloop(self)
        self._history = []
        self._locals = {}
        self._globals = {}

    def precmd(self, line):
        """
        This method is called after the line has been input but before
        it has been interpreted. If you want to modifdy the input line
        before execution (for example, variable substitution) do it here.
        """
        self._history += [line.strip()]
        return line

    def postloop(self):
        """
        Take care of any unfinished business.
        """
        cmd.Cmd.postloop(self)
        print("Exiting...")

    def postcmd(self, stop, line):
        """
        If you want to stop the console, return something that evaluates to true.
        If you want to do some post command processing, do it here.
        """
        return stop

    def emptyline(self):
        """
        Do nothing on empty line input.
        """
        pass

    def do_prompt(self, args):
        """
        Change console prompt.
        $ prompt [new prompt] - set new prompt.
        """
        self.prompt = "{0}:~$ ".format(args)

    def do_help(self, args):
        """
        Get help on commands:
        'help' or '?' with no arguments prints a list of commands for which help is available
        'help <command>' or '? <command>' gives help on <command>
        """
        cmd.Cmd.do_help(self, args)

    def do_history(self, args):
        """
        Print a list of commands that have been entered into console.
        """
        print(self._history)

    def do_clear(self, args):
        """
        Clear the screen.
        """
        os.system("clear")

    def do_shell(self, line):
        """
        Pass command to a system shell when line begins with '!'
        """
        print("Running shell command: {0}\n".format(line))
        sub_cmd = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE)
        output = sub_cmd.communicate()[0].decode("utf-8")
        print(output)
        self.last_output = output

    def do_echo(self, line):
        """
        Print the input, replacing '$out' with the output of the last shell command.
        """
        print(line.replace("$out", self.last_output))

    def do_quit(self, args):
        """
        Quits from the console.
        """
        print("Quitting...")
        sys.exit(0)

    def do_exit(self, args):
        """
        Exits from the console.
        """
        print("Exiting...")
        sys.exit(0)

    def do_EOF(self, line):
        """
        Exit on system end of file character (Ctrl+D).
        """
        return True

    def do_leave(self, line):
        """
        Leave submenu.
        """
        return True

    def do_show(self, line):
        """Execute command in cluster information menu."""
        Show().onecmd(line)

    def complete_show(self, text, line, begidx, endidx):
        return [i for i in commandlist(Show()) if i.startswith(text)]

    # Elasticsearch cluster
    def do_cluster_reroute_retry_field_shards(self, args):
        """
        Retries allocation of shards that are blocked due to too many subsequent allocation failures.
        """
        print()
        print(es.cluster.reroute(master_timeout="300s", retry_failed=True))
        print()

    def do_cluster_settings_transient(self, args):
        """
        Update cluster wide specific settings.
        Resetting transient settings can be done by assigning a 'null' value. Strings must be in " ".
        $ cluster_settings_transient <setting> <value> - change cluster transient <setting> to new <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter setting and its value.")
                print()
            else:
                try:
                    setme = '{{ "transient": {{ "{0}" : {1} }} }}'.format(str(parms[0]), str(parms[1]))
                    print()
                    print("Setting: " + setme)
                    print()
                    es.cluster.put_settings(body=setme, flat_settings=True, timeout="300s")
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            try:
                print()
                print("Please enter setting and its value.")
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def do_cluster_settings_persistent(self, args):
        """
        Update cluster wide specific settings.
        Resetting persistent settings can be done by assigning a 'null' value. String must be in " ".
        $ cluster_settings_persistent <setting> <value> - change cluster persistent <setting> to new <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter setting and its value.")
                print()
            else:
                try:
                    setme = '{{ "persistent": {{ "{0}" : {1} }} }}'.format(str(parms[0]), str(parms[1]))
                    print()
                    print("Setting: " + setme)
                    print()
                    print(es.cluster.put_settings(body=setme, flat_settings=True, timeout="300s"))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            try:
                print()
                print("Please enter setting and its value.")
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    # Elasticsearch indices
    def do_indices_settings(self, args):
        """
        Change specific index level settings in real time.
        $ indices_settings [index] [setting] [value] - change <index> static or dynamic <setting> to new <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter setting and its value.")
                print()
            else:
                try:
                    setme = '{{ "index": {{ "{0}" : {1} }} }}'.format(str(parms[1]), str(parms[2]))
                    print()
                    print("Setting: " + setme)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=setme))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            try:
                print()
                print("Please enter setting and its value.")
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def do_indices_refresh(self, args):
        """
        Explicitly refresh one or more index, making all operations performed since last
        refresh available for search.
        $ indices_refresh [index] - perform refresh on <index>.
        """
        if args:
            try:
                print()
                print(es.indices.refresh(index=args))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter the index name.")
            print()

    def complete_indices_refresh(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_flush(self, args):
        """
        Perform a normal flush, then add a generated unique marker (sync_id) to all shards.
        $ indices_flush [index] - preform a synced flush on <index>.
        """
        if args:
            try:
                print()
                print(es.indices.flush_synced(index=args))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter the index name.")
            print()

    def complete_indices_flush(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_create(self, args):
        """
        Create an empty index in Elasticsearch.
        $ indices_create [index] - create <index>.
        """
        if args:
            try:
                print()
                print(es.indices.create(index=args, timeout="300s", wait_for_active_shards="all"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index name to create.")
            print()

    def do_indices_create_compressed(self, args):
        """
        Create an empty index in Elasticsearch with best compression.
        $ indices_create_compressed [index] - create <index> with best compression.
        """
        if args:
            try:
                print()
                print(es.indices.create(index=args, timeout="300s", wait_for_active_shards="all",
                                        body='{ "settings": { "index.codec": "best_compression" } }'))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index name to create.")
            print()

    def do_indices_templates_delete(self, args):
        """
        Delete an index template by its name.
        $ indices_templates_delete [template] - delete <template>.
        """
        if args:
            try:
                print()
                print(es.indices.delete_template(name=args, master_timeout="300s"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter template name to delete.")
            print()

    def do_indices_analyze_standard(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_standard you know for search
        """
        if args:
            try:
                print()
                print(es.indices.analyze(analyzer="standard", text=args))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_analyze_simple(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_simple you know for search
        """
        if args:
            try:
                print()
                print(es.indices.analyze(analyzer="simple", text=args))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_analyze_whitespace(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_whitespace you know for search
        """
        if args:
            try:
                print()
                print(es.indices.analyze(analyzer="whitespace", text=args))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_analyze_stop(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_stop you know for search
        """
        if args:
            try:
                print()
                print(es.indices.analyze(analyzer="stop", text=args))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_analyze_keyword(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_keyword you know for search
        """
        if args:
            try:
                print()
                print(es.indices.analyze(analyzer="keyword", text=args))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_analyze_fingerprint(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_fingerprint you know for search
        """
        if args:
            try:
                print()
                print(es.indices.analyze(analyzer="fingerprint", text=args))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_reindex(self, args):
        """
        Reindex all documents from one index to another.
        $ indices_reindex [index] [index]_old - copy documents from the <index> into the <index>_old.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please source and destination index.")
                print()
            else:
                try:
                    reindex = '{{ "source": {{ "index": "{0}" }}, "dest": {{ "index": "{1}" }} }}'.format(parms[0],
                                                                                                          parms[1])
                    print()
                    print("Executing: " + reindex)
                    print()
                    print(es.reindex(body=reindex, wait_for_active_shards="all", wait_for_completion=False))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter source and destination index.")
            print()

    def do_indices_number_of_replicas(self, args):
        """
        Change the the number of replicas each primary shard has.
        $ indices_number_of_replicas [index] 0 - disable replication of <index>.
        $ indices_number_of_replicas [index] 1 - enable replication of <index>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and number of replicas.")
                print()
            else:
                try:
                    replicaset = '{{ "index": {{ "number_of_replicas": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + replicaset)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=replicaset))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index and number of replicas.")
            print()

    def do_indices_auto_expand_replicas(self, args):
        """
        Auto-expand the number of replicas based on number of available nodes. Set to a dash delimited
        lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all). Defaults to false.
        $ indices_auto_expand_replicas [index] [range] - change <index> auto-expand replicas to <range>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and number of auto-expand replicas.")
                print()
            else:
                try:
                    replicaset = '{{ "index": {{ "auto_expand_replicas": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + replicaset)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=replicaset))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index and number of auto-expand replicas.")
            print()

    def do_indices_refresh_interval(self, args):
        """
        How often to perform a refresh operation, which makes recent changes to the index visible to search.
        Defaults to 1s. Can be set to -1 to disable refresh.
        $ indices_refresh_interval [index] [value] - change <index> refresh interval to <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and refresh value in seconds.")
                print()
            else:
                try:
                    refreshset = '{{ "index": {{ "refresh_interval": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + refreshset)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=refreshset))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index and refresh value in seconds.")
            print()

    def do_indices_max_result_window(self, args):
        """
        The maximum value of 'from+size' for searches to this index. Defaults to 10.000. Search request take
        heap memory and time proportional to 'from+size' and this limits that memory.
        $ indices_max_result_window [index] [value] - change <index> max result window to <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and max result window value.")
                print()
            else:
                try:
                    maxwindow = '{{ "index": {{ "max_result_window": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + maxwindow)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=maxwindow))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index and max result window value.")
            print()

    def do_indices_max_rescore_window(self, args):
        """
        The maximum value of window_size for rescores in searches of this index. Defaults to
        'index.max_result_window' which defaults to 10.000. Search request take heap memory and time
        proportional to max(window_size, from+size) and this limits that memory.
        $ indices_max_rescore_window [index] [value] - change <index> max rescore window to <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and max rescore window value.")
                print()
            else:
                try:
                    maxwindow = '{{ "index": {{ "max_rescore_window": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + maxwindow)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=maxwindow))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index and max rescore window value.")
            print()

    def do_indices_blocks_read_only(self, args):
        """
        Set to true to make the index and index metadata read only, false to allow writes and metadata changes.
        $ indices_blocks_read_only [index] [true|false] - make <index> na meta data read only or read/write.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and Boolen value.")
                print()
            else:
                try:
                    readonly = '{{ "index": {{ "blocks.read_only": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + readonly)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=readonly))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index and Boolen value.")
            print()

    def do_indices_blocks_read(self, args):
        """
        Set to true to disable read operations against the index.
        $ indices_blocks_read [index] [true|false] - make <index> write only.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and Boolen value.")
                print()
            else:
                try:
                    readonly = '{{ "index": {{ "blocks.read": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + readonly)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=readonly))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index and Boolen value.")
            print()

    def do_indices_blocks_write(self, args):
        """
        Set to true to disable write operations against the index.
        $ indices_blocks_write [index] [true|false] - make <index> read only.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and Boolen value.")
                print()
            else:
                try:
                    readonly = '{{ "index": {{ "blocks.write": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + readonly)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=readonly))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index and Boolen value.")
            print()

    def do_indices_blocks_metadata(self, args):
        """
        Set to true to disable index metadata reads and writes.
        $ indices_blocks_metadata [index] [true|false] - block <index> metadata for writes and reads.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and Boolen value.")
                print()
            else:
                try:
                    readonly = '{{ "index": {{ "blocks.metadata": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + readonly)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=readonly))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index and Boolen value.")
            print()

    def do_indices_search(self, args):
        """
        Execute a search query and get back search hits that match the query.
        $ indices_search [index] *:* 10 - return 10 hits of query <index> in the Lucene query string syntax.

        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter index, query and number of hits to return.")
                print()
            else:
                try:
                    less(json.dumps(es.search(index=parms[0], q=parms[1], size=parms[2]), indent=2))
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index, query and number of hits to return.")
            print()

    def do_indices_force_merge(self, args):
        """
        The force merge API allows to force merging of one or more indices through an API.
        The merge relates to the number of segments a Lucene index holds within each shard.
        The force merge operation allows to reduce the number of segments by merging them.
        $ indices_forcemerge [index] [number] - merge <index> to <number> of segments.
        """
        parms = args.split()
        if len(parms) != 2:
            print()
            print("Invalid number of arguments. Please provide index name nad number of segments.")
            print()
        else:
            try:
                print()
                print(es.indices.forcemerge(index=parms[0], max_num_segments=parms[1]))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_force_merge(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_aliases_delete(self, args):
        """
        Delete specific alias.
        $ indices_aliases_delete [alias] [index] - delete <alias> for <index> (use _all for all indices or aliases).
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter alias and index name.")
                print()
            else:
                try:
                    print()
                    print(es.indices.delete_alias(name=parms[0], index=parms[1]))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Invalid number of arguments. Please enter alias and index name.")
            print()

    def do_indices_aliases_create(self, args):
        """
        Create an alias for a specific index/indices.
        $ indices_aliases_create [alias] [index] - create <alias> for <index> (use _all for all indices).
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter alias and index name.")
                print()
            else:
                try:
                    print()
                    print(es.indices.put_alias(name=parms[0], index=parms[1]))
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Invalid number of arguments. Please enter alias and index name.")
            print()

    def do_indices_delete(self, args):
        """
        Delete an index in Elasticsearch.
        $ indices_delete [index] - delete the specified <index>.
        """
        if args:
            try:
                print()
                print(es.indices.delete(index=args, master_timeout="300s"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Missing index or a comma-separated list of indices to delete.")
            print()

    def complete_indices_delete(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_close(self, args):
        """
        Close an index to remove it's overhead from the cluster.
        Closed index is blocked for read/write operations.
        $ indices_close <index> - close the specified <index>.
        """
        if args:
            try:
                print()
                print(es.indices.close(index=args, master_timeout="300s"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Missing index or a comma-separated list of indices to close.")
            print()

    def complete_indices_close(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_open(self, args):
        """
        Open a closed index to make it available for search.
        $ indices_open [index] - open the specified <index>.
        """
        if args:
            try:
                print()
                print(es.indices.open(index=args, master_timeout="300s"))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Missing index or a comma-separated list of indices to open.")
            print()

    def complete_indices_open(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache(self, args):
        """
        Clear either all caches or specific cached associated with one or more indices.
        $ indices_clear_cache  [index] - clear cache of the specified <index>.
        $ indices_clear_cache - clear all caches (default)
        """
        if args:
            try:
                print()
                print(es.indices.clear_cache(index=args))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.indices.clear_cache())
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_clear_cache(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_fielddata(self, args):
        """
        Clear field data.
        $ indices_clear_cache_fielddata [index] - clear field data of the specified <index>.
        $ indices_clear_cache_fielddata - clear field data of all indices (default).
        """
        if args:
            try:
                print()
                print(es.indices.clear_cache(index=args, fielddata=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.indices.clear_cache(fielddata=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_clear_cache_fielddata(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_query(self, args):
        """
        Clear query caches.
        $ indices_clear_cache_query [index] - clear query caches of the specified <index>.
        $ indices_clear_cache_query - clear query caches of all indices (default).
        """
        if args:
            try:
                print()
                print(es.indices.clear_cache(index=args, query=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.indices.clear_cache(query=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_clear_cache_query(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_recycler(self, args):
        """
        Clear the recycler cache.
        $ indices_clear_cache_recycler [index] - clear the recycler cache of the specified <index>.
        $ indices_clear_cache_recycler - clear the recycler cache of all indices (default).
        """
        if args:
            try:
                print()
                print(es.indices.clear_cache(index=args, recycler=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.indices.clear_cache(recycler=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_clear_cache_recycler(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_request(self, args):
        """
        Clear the request cache.
        $ indices_clear_cache_request [index] - clear the request cache of the specified <index>.
        $ indices_clear_cache request - clear the request cache of all indices (default).
        """
        if args:
            try:
                print()
                print(es.indices.clear_cache(index=args, request=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            try:
                print()
                print(es.indices.clear_cache(request=True))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))

    def complete_indices_clear_cache_request(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    # Elasticsearch shards
    def do_shards_allocate_replica_dry_run(self, args):
        """
        Simulate allocate an unassigned replica shard to a node. Accepts the <index> for index name and
        <shard_number>, and <dest_node> to allocate the shard to.
        $ shards_allocate_replica_dry_run [index] [numer] [node] - simulate allocate shard <number> of <index> to <node>.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter index_name shard_number and dest_node.")
                print()
            else:
                try:
                    allocme = '{{ "commands": [ {{ "allocate_replica": {{ "index": "{0}", "shard": {1}, "node": "{2}" }} }} ] }}'.format(
                        str(parms[0]), str(parms[1]), str(parms[2]))
                    print()
                    print("Executing: " + allocme)
                    print()
                    pretty_print(es.cluster.reroute(body=allocme, dry_run=True, explain=True, metric="master_node"),
                                 indent=2)
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Invalid number of arguments. Please enter index_name shard_number and dest_node.")
            print()

    def complete_shards_allocate_replica_dry_run(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_move_dry_run(self, args):
        """
        Simulate move started shard from one node to another node.  Accepts <index> for index name and
        <shard_number>, <from_node> for the node to move the shard from, and <to_node> for the node to
        move the shard to.
        $ shards_move_dry_run [index] [number] [src_node] [dst_node] - simulate move shard <number> of <index>
          from <src_node> to <dst_node>.
        """
        if args:
            parms = args.split()
            if len(parms) != 4:
                print()
                print("Invalid number of arguments. Please enter index_name shard_number from_node to_node.")
                print()
            else:
                try:
                    moveme = '{{ "commands": [ {{ "move": {{ "index": "{0}", "shard": {1}, "from_node": "{2}",' \
                             '"to_node": "{3}" }} }} ] }}'.format(str(parms[0]), str(parms[1]), str(parms[2]),
                                                                  str(parms[3]))
                    print()
                    print("Executing: " + moveme)
                    print()
                    pretty_print(es.cluster.reroute(body=moveme, dry_run=True, explain=True, metric="master_node"),
                                 indent=2)
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index_name shard_number from_node to_node.")
            print()

    def complete_shards_move_dry_run(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_move(self, args):
        """
        Move started shard from one node to another node.  Accepts <index> for index name and
        <shard_number>, <from_node> for the node to move the shard from, and <to_node> for the
        node to move the shard to.
        $ shards_move [index] [number] [src_node] [dst_node] - move shard <number> of <index>
          from <src_node> to <dst_node>.
        """
        if args:
            parms = args.split()
            if len(parms) != 4:
                print()
                print("Invalid number of arguments. Please enter index_name shard_number from_node to_node.")
                print()
            else:
                try:
                    moveme = '{{ "commands": [ {{ "move": {{ "index": "{0}", "shard": {1}, "from_node": "{2}",' \
                             '"to_node": "{3}" }} }} ] }}'.format(str(parms[0]), str(parms[1]), str(parms[2]),
                                                                  str(parms[3]))
                    print()
                    print("Executing: " + moveme)
                    print()
                    pretty_print(es.cluster.reroute(body=moveme, explain=True, metric="master_node"), indent=2)
                    print()
                except Exception:
                    print(format(BColors.FAIL))
                    print(traceback.print_exc(limit=1, file=sys.stdout))
                    print(format(BColors.ENDC))
        else:
            print()
            print("Please enter index_name shard_number from_node to_node.")
            print()

    def complete_shards_move(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    # Elasticsearch nodes
    def do_nodes_tasks_cancel(self, args):
        """
        Cancel the task with specified task id (node_id:task_number).
        $ nodes_tasks_cancel [node_id:task_number] - cancel <task> on <node>.
        """

        if args:
            try:
                print()
                print(json.dumps(es.tasks.cancel(task_id=args), indent=4))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter node_id and task_number in format: node_id:task_number.")
            print()

    # Elasticsearch search
    def do_search_clear_scroll(self, args):
        """
        Clear the scroll request created by specifying the scroll parameter to search.
        $ search_clear_scroll [scroll_id] - clear the <scroll_id>.
        """
        if args:
            try:
                print()
                print(es.clear_scroll(scroll_id=args))
                print()
            except Exception:
                print(format(BColors.FAIL))
                print(traceback.print_exc(limit=1, file=sys.stdout))
                print(format(BColors.ENDC))
        else:
            print()
            print("Please enter a comma-separated list of scroll IDs to clear.")
            print()


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("No elasticsearch server specified. Using default localhost.{0}".format(BColors.ENDC))
        if isopen("127.0.0.1", 9200):
            host = "127.0.0.1"
        else:
            sys.exit(2)
    elif len(sys.argv) == 2:
        if check_hostname(sys.argv[1]):
            print(BColors.HEADER + "Connecting to elasticsearch server at address: {0:s}".format(sys.argv[1]) +
                  BColors.ENDC)
            if isopen(sys.argv[1], 9200):
                host = sys.argv[1]
            else:
                sys.exit(2)
        elif check_ip(sys.argv[1]):
            print(BColors.HEADER + "Connecting to elasticsearch server at address: {0:s}".format(sys.argv[1]) +
                  BColors.ENDC)
            if isopen(sys.argv[1], 9200):
                host = sys.argv[1]
            else:
                sys.exit(2)
        else:
            print("Wrong DNS or IP elasticsearch node address.")
    else:
        sys.exit("Usage: {0} [ES master IP/DNS address]".format(sys.argv[0]))
    try:
        if "libedit" in readline.__doc__:
            readline.parse_and_bind("bind ^I rl_complete")
        else:
            readline.parse_and_bind("tab: complete")
        if "ESAUTH" in os.environ:
            host = "http://{0}@{1}:9200".format(os.environ["ESAUTH"], host)
        else:
            host = "http://{0}:9200".format(host)
        es = elasticsearch.Elasticsearch([host], sniff_on_start=False, sniff_on_connection_fail=False,
                                         sniffer_timeout=None, timeout=300, retry_on_timeout=True, retry_on_status=True,
                                         max_retries=3)
        esconsole = ES()
        esconsole.cmdloop()
    except KeyboardInterrupt:
        error("Exiting...")
    except Exception:
        print(format(BColors.FAIL))
        print(traceback.print_exc(limit=1, file=sys.stdout))
        print(format(BColors.ENDC))
