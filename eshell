#!/usr/bin/env python
# -*- coding: utf-8 -*-
# -----------------
# title            : eShell
# description      : Elasticsearch API available via Python interactive shell.
# author           : Patryk Krawaczyński
# update date      : 17.10.2019
# version          : 0.6.8.3
# license          : Apache License (2.0)
# usage            : ./eshell [es master ip | es master hostname]
# python version   : 3.7.6
# required modules : requests 2.22.0 (http://docs.python-requests.org/en/master/)
#                  : elasticsearch 6.3.1 (http://elasticsearch-py.readthedocs.org/en/master/)
# notes            : https://github.com/nfsec/eshell
# -----------------

import cmd
import json
import logging.handlers
import operator
import os
import re
import socket
import subprocess
import sys
import ssl
import traceback
import elasticsearch
import readline
import requests
import warnings
import getpass
import atexit


# Helpers
def error():
    """
    Print error and traceback.
    """
    print(format(BColors.FAIL))
    print("-" * 60)
    print(traceback.print_exc(file=sys.stdout))
    print("-" * 60)
    print(format(BColors.ENDC))


def check_ip(ip):
    """
    Check if IP address is valid one.
    """
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        return False


def check_hostname(hostname):
    """
    Check if DNS address is valid one.
    """
    try:
        socket.gethostbyname(hostname)
        return True
    except socket.error:
        return False


def less(text):
    try:
        pager = subprocess.Popen(["less", "-F", "-R", "-S", "-X", "-K", "-N"], stdin=subprocess.PIPE, stdout=sys.stdout)
        for line in text:
            pager.stdin.write(line.encode("utf-8"))
        pager.stdin.close()
        pager.wait()
    except IOError:
        print("Exiting...")
    except KeyboardInterrupt:
        print("Exiting...")


def isopen(ip, port):
    """
    Check if IP address have open port.
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1)
    try:
        s.connect((ip, port))
        s.settimeout(None)
        s.shutdown(2)
        print("Connected to: {0} on port: {1}".format(str(ip), str(port)))
        return True
    except socket.error as e:
        print("Problem with connection to: {0} on port: {1}. Error code:".format(str(ip), str(port)), e)
        return False


def commandlist(subcommand):
    commands = []
    for i in dir(subcommand):
        if i.startswith("do_"):
            commands.append(i.replace("do_", ""))
    return commands


def pretty_print(dictionary, indent=0):
    """
    Pretty print all the complexities.
    """
    for k, v in sorted(dictionary.items()):
        if type(v) == dict:
            if len(v) == 0:
                print(" " * indent, str(k) + ": {empty}")
            else:
                print(" " * indent, str(k) + ": ")
                pretty_print(v, indent + len(k) + 1)
        elif type(v) == list:
            if len(v) == 0:
                print(" " * indent, str(k) + ": [empty]")
            elif type(v[0]) == dict:
                print(" " * indent, str(k) + ": ")
                for x in v:
                    pretty_print(x, indent + len(k) + 1)
            else:
                print(" " * indent, str(k) + ": " + str.join(", ", v))
        else:
            print(" " * indent, str(k) + ": " + str(v))


# Autocomplete functions
def indexlist():
    indices = []
    for i in es.cat.indices(h="index").split("\n"):
        if i:
            indices.append(i.replace(" ", ""))
    return indices


def nodelist():
    nodes = []
    for i in es.cat.nodes(h="name").split("\n"):
        if i:
            nodes.append(i)
    return nodes


# Colors for terminal
class BColors:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


# Elasticsearch console
class ES(cmd.Cmd):
    intro = "{0}\n### Welcome to ElasticSearch Shell console!\n### For more information, type \"help\" or \"?\".\n" \
            "### Session will be logged to ~/.eshell/es.log.\n" \
            "### Command history will be saved to ~/.eshell/history.\n{1}".format(
        BColors.BOLD, BColors.ENDC)
    prompt = "es:~$ "
    ruler = "-"
    doc_header = "Available commands (type: help <command>):"

    def default(self, line):
        """
        Called on an input line when the command prefix is not recognized.
        In that case we execute the line as Python code.
        """
        try:
            exec(line) in self._locals, self._globals
        except NameError:
            print("Command {0} not found.".format(line))
        except SyntaxError:
            print("Command not found or invalid syntax.")
        except KeyboardInterrupt:
            print("Detected Ctrl+D. Exiting...")
        except Exception as e:
            print("{0} : {1}".format(e.__class__, e))

    def preloop(self):
        """
        Initialization before prompting user for commands.
        """
        self._history = []
        self._locals = {}
        self._globals = {}

    def precmd(self, line):
        """
        This method is called after the line has been input but before
        it has been interpreted. If you want to modifdy the input line
        before execution (for example, variable substitution) do it here.
        """
        self._history += [line.strip()]
        return line

    def postloop(self):
        """
        Take care of any unfinished business.
        """
        cmd.Cmd.postloop(self)
        print("Exiting...")

    def postcmd(self, stop, line):
        """
        If you want to stop the console, return something that evaluates to true.
        If you want to do some post command processing, do it here.
        """
        return stop

    def emptyline(self):
        """
        Do nothing on empty line input.
        """
        pass

    def do_prompt(self, args):
        """
        Change console prompt.
        $ prompt [new prompt] - set new prompt.
        """
        self.prompt = "{0}:~$ ".format(args)

    def do_help(self, args):
        """
        Get help on commands:
        'help' or '?' with no arguments prints a list of commands for which help is available
        'help <command>' or '? <command>' gives help on <command>
        """
        cmd.Cmd.do_help(self, args)

    def do_history(self, args):
        """
        Print a list of commands that have been entered into console.
        """
        print(self._history)

    def do_clear(self, args):
        """
        Clear the screen.
        """
        os.system("clear")

    def do_shell(self, line):
        """
        Pass command to a system shell when line begins with '!'
        """
        print("Running shell command: {0}\n".format(line))
        sub_cmd = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE)
        output = sub_cmd.communicate()[0].decode("utf-8")
        print(output)
        self.last_output = output

    def do_echo(self, line):
        """
        Print the input, replacing '$out' with the output of the last shell command.
        """
        print(line.replace("$out", self.last_output))

    def do_quit(self, args):
        """
        Quits from the console.
        """
        return True

    def do_exit(self, args):
        """
        Exits from the console.
        """
        return True

    def do_EOF(self, line):
        """
        Exit on system end of file character (Ctrl+D).
        """
        return True

    def do_show(self, args):
        """
        Enter to cluster information submenu.
        """
        show_cli = Show()
        show_cli.cmdloop()

    def do_exec(self, args):
        """
        Enter to cluster execution submenu.
        """
        exec_cli = Exec()
        exec_cli.cmdloop()


class Show(cmd.Cmd):
    intro = "\n{0}### Entering to cluster information menu!\n### For more information, type \"help\" or \"?\".\n{1}". \
        format(BColors.BOLD, BColors.ENDC)
    prompt = "es:show~$ "
    ruler = "-"
    doc_header = "Available commands (type: help <command>):"

    def default(self, line):
        """
        Called on an input line when the command prefix is not recognized.
        In that case we execute the line as Python code.
        """
        try:
            exec(line) in self._locals, self._globals
        except NameError:
            print("Command {0} not found.".format(line))
        except SyntaxError:
            print("Command not found or invalid syntax.")
        except KeyboardInterrupt:
            print("Detected Ctrl+D. Exiting...")
        except Exception as e:
            print("{0} : {1}".format(e.__class__, e))

    def preloop(self):
        """
        Initialization before prompting user for commands.
        """
        cmd.Cmd.preloop(self)
        self._history = []
        self._locals = {}
        self._globals = {}

    def precmd(self, line):
        """
        This method is called after the line has been input but before
        it has been interpreted. If you want to modifdy the input line
        before execution (for example, variable substitution) do it here.
        """
        self._history += [line.strip()]
        return line

    def postloop(self):
        """
        Take care of any unfinished business.
        """
        cmd.Cmd.postloop(self)
        print("Exiting...")

    def postcmd(self, stop, line):
        """
        If you want to stop the console, return something that evaluates to true.
        If you want to do some post command processing, do it here.
        """
        return stop

    def emptyline(self):
        """
        Do nothing on empty line input.
        """
        pass

    def do_prompt(self, args):
        """
        Change console prompt.
        $ prompt [new prompt] - set new prompt.
        """
        self.prompt = "{0}:~$ ".format(args)

    def do_help(self, args):
        """
        Get help on commands:
        'help' or '?' with no arguments prints a list of commands for which help is available
        'help <command>' or '? <command>' gives help on <command>
        """
        cmd.Cmd.do_help(self, args)

    def do_history(self, args):
        """
        Print a list of commands that have been entered into console.
        """
        print(self._history)

    def do_clear(self, args):
        """
        Clear the screen.
        """
        os.system("clear")

    def do_shell(self, line):
        """
        Pass command to a system shell when line begins with '!'
        """
        print("Running shell command: {0}\n".format(line))
        sub_cmd = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE)
        output = sub_cmd.communicate()[0].decode("utf-8")
        print(output)
        self.last_output = output

    def do_echo(self, line):
        """
        Print the input, replacing '$out' with the output of the last shell command.
        """
        print(line.replace("$out", self.last_output))

    def do_quit(self, args):
        """
        Quits from the console.
        """
        return True

    def do_exit(self, args):
        """
        Exits from the console.
        """
        return True

    def do_EOF(self, line):
        """
        Exit on system end of file character (Ctrl+D).
        """
        return True

    def do_leave(self, line):
        """
        Leave submenu.
        """
        return True

    def do_exec(self, line):
        """
        Execute command in cluster execution menu.
        """
        Exec().onecmd(line)

    def complete_exec(self, text, line, begidx, endidx):
        return [i for i in commandlist(Exec()) if i.startswith(text)]

    # Elasticsearch cluster
    def do_cluster_allocation_explain(self, args):
        """
        The purpose of the cluster allocation explain API is to provide explanations for shard allocations in the
        cluster. For unassigned shards, the explain API provides an explanation for why the shard is unassigned.
        $ cluster_allocation_explain - explain the first unassigned shard.
        $ cluster_allocation_explain [index] [shard_id] [true] - specify the index and shard id of the shard you would
          like a explanation for, as well as the primary flag to indicate whether to explain the primary shard for the
          given shard id or one of its replica shards. These three request parameters are required.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please provide index name, shard id and true or false if primary.")
                print()
            else:
                try:
                    showme = '{{ "index": "{0}", "shard": {1}, "primary": {2} }}'.format(str(parms[0]), str(parms[1]),
                                                                                         str(parms[2]))
                    print()
                    pretty_print(es.cluster.allocation_explain(body=showme), indent=2)
                    print()
                except Exception:
                    error()
        else:
            try:
                print()
                pretty_print(es.cluster.allocation_explain(include_disk_info=True), indent=2)
                print()
            except Exception:
                error()

    def do_cluster_repositories(self, args):
        """
        The repositories command shows the snapshot repositories registered in the cluster.
        """
        try:
            print()
            print(es.cat.repositories(v=True, s="id"))
        except Exception:
            error()

    def do_cluster_snapshots(self, args):
        """
        The cluster_snapshots command shows all snapshots that belong to a specific repository.
        $ cluster_snapshots [repository_name] - show information about each snapshot in repository.
        """
        if args:
            try:
                print()
                print(es.cat.snapshots(repository=args, ignore_unavailable=True, v=True, s="id"))
            except Exception:
                error()
        else:
            print()
            print("Please provide name of repository to show its snapshots. ")
            print("To find a list of available repositories to query, the command 'cluster_repositories' can be used.")
            print()

    def do_cluster_ping(self, args):
        """
        Returns 'UP' if the cluster is up, 'DOWN' otherwise.
        """
        try:
            if es.ping():
                print("\nUP!\n")
            else:
                print("\nDOWN!\n")
        except Exception:
            error()

    def do_cluster_info(self, args):
        """
        Get the basic info from the current cluster.
        """
        try:
            print()
            pretty_print(es.info(), indent=2)
            print()
        except Exception:
            error()

    def do_cluster_master(self, args):
        """
        Displays the master’s node ID, bound IP address, and node name.
        """
        try:
            print()
            print(es.cat.master(v=True))
        except Exception:
            error()

    def do_cluster_health(self, args):
        """
        Get a very simple status on the health of the cluster.
        $ cluster_health - show cluster health.
        $ cluster_health table - one-line representation of the same information from cluster_health.
        """
        try:
            if args == "table":
                print()
                print(es.cat.health(v=True))
            else:
                print()
                pretty_print(es.cluster.health(level="cluster"), indent=2)
                print()
        except Exception:
            error()

    def do_cluster_tasks(self, args):
        """
        Show all pending cluster tasks which have not yet been executed.
        $ cluster_tasks urgent - show urgent tasks.
        $ cluster_tasks high - show high tasks.
        $ cluster_tasks normal - show normarl tasks.
        $ cluster_tasks - show all tasks (default).
        """
        try:
            task_list = es.cat.pending_tasks(v=True)
            if args in ["urgent", "high", "normal"]:
                print()
                print(task_list.split("\n")[0])
                for line in task_list.split("\n"):
                    if args.upper() in line:
                        print(line)
                print()
            else:
                print()
                less(es.cat.pending_tasks())
                print()
        except Exception:
            error()

    def do_cluster_tasks_stats(self, args):
        """Show cluster tasks statistics."""
        task_list = requests.get("{0}/_cat/pending_tasks?v=True".format(host))
        ustats = re.compile("URGENT")
        umatch = ustats.findall(task_list.content.decode("utf-8"))
        hstats = re.compile("HIGH")
        hmatch = hstats.findall(task_list.content.decode("utf-8"))
        nstats = re.compile("NORMAL")
        nmatch = nstats.findall(task_list.content.decode("utf-8"))
        print("Tasks statistics: URGENT: {0} HIGH: {1} NORMAL: {2}".format(str(len(umatch)), str(len(hmatch)), str(
            len(nmatch))))

    def do_cluster_settings(self, args):
        """
        Get current cluster settings.
        $ cluster_settings - get cluster custom settings.
        """
        try:
            print()
            pretty_print(es.cluster.get_settings(flat_settings=True), indent=2)
            print()
        except Exception:
            error()

    def do_cluster_settings_with_defaults(self, args):
        """
        Get current cluster settings.
        $ cluster_settings_with_defaults - get cluster default settings.
        """
        try:
            print()
            pretty_print(es.cluster.get_settings(flat_settings=True, include_defaults=True), indent=2)
            print()
        except Exception:
            error()

    def do_cluster_stats(self, args):
        """
        The Cluster stats allows to retrieve statistics from a cluster wide perspective.
        $ cluster_stats [node_id] - show stats for node_id.
        $ cluster_stats _all - show stats for all nodes.
        $ cluster_stats _local - show stats only for local node.
        $ cluster_stats _master - show stats for the currently-elected master node.
        $ cluster_stats master:true/false - show/hide stats for all master-eligible nodes.
        $ cluster_stats data:true/false - show/hide stats for all data nodes.
        $ cluster_stats ingest:true/false - show/hide for all ingest nodes.
        $ cluster_stats coordinating_only:true/false - show/hide for all coordinating-only nodes.
        """
        if args:
            try:
                print()
                pretty = es.cluster.stats(node_id=args)
                pretty_print(pretty, indent=7)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty = es.cluster.stats(human=True)
                print("cluster_name: {0}".format(str(pretty["cluster_name"])))
                print("status: {0}".format(str(pretty["status"])))
                print("timestamp: {0}".format(str(pretty["timestamp"])))
                print("_nodes")
                pretty_print(pretty["_nodes"], indent=7)
                print("nodes:")
                pretty_print(pretty["nodes"], indent=6)
                print("indices:")
                pretty_print(pretty["indices"], indent=8)
                print()
            except Exception:
                error()

    def do_cluster_state(self, args):
        """
        Shows the cluster state.
        """
        try:
            print()
            pretty = es.cluster.state(metric="_all", flat_settings=True)
            pretty_print(pretty, indent=2)
            print()
        except Exception:
            error()

    def do_cluster_state_version(self, args):
        """
        Shows the cluster state version.
        """
        try:
            print()
            pretty = es.cluster.state(metric="version", flat_settings=True)
            pretty_print(pretty, indent=2)
            print()
        except Exception:
            error()

    def do_cluster_state_nodes(self, args):
        """
        Shows the cluster nodes part of the response.
        """
        try:
            print()
            pretty = es.cluster.state(metric="nodes", flat_settings=True)
            pretty_print(pretty, indent=2)
            print()
        except Exception:
            error()

    def do_cluster_state_blocks(self, args):
        """
        Shows the cluster blocks part of the response.
        """
        try:
            print()
            pretty = es.cluster.state(metric="blocks", flat_settings=True)
            pretty_print(pretty, indent=2)
            print()
        except Exception:
            error()

    def do_cluster_remote(self, args):
        """
        This command returns connection and endpoint information keyed to the configured remote cluster alias.

        - seeds - the configured initial seed transport addresses of the remote cluster.
        - http_addresses - the published http addresses of all connected remote nodes.
        - connected - true if there is at least one connection to the remote cluster.
        - num_nodes_connected - the number of connected nodes in the remote cluster.
        - max_connections_per_cluster - the maximum number of connections maintained for the remote cluster.
        - initial_connect_timeout - the initial connect timeout for remote cluster connections.
        - skip_unavailable - whether the remote cluster is skipped in case it is searched through a cross-cluster search
          request but none of its nodes are available.
        """
        try:
            print()
            info = requests.get("{0}/_remote/info?pretty".format(host))
            pretty_print(info.json())
            print()
        except Exception:
            error()

    # Elasticsearch indices
    def do_indices_recovery(self, args):
        """
        The indices recovery API provides insight into on-going index shard recoveries.
        $ indices_recovery [index] - recovery status reported for specific indices.
        $ indices_recovery - recovery status reported cluster-wide
        """
        if args:
            try:
                print()
                pretty_print(es.indices.recovery(index=args, detailed=True))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.recovery(detailed=True))
                print()
            except Exception:
                error()

    def do_indices_head(self, args):
        """
        Show the [number] of first documents in the index.
        $ indices_head [index] [number] - show the <number> of first documents in the <index>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index name and number of documents.")
                print()
            else:
                try:
                    print()
                    print(json.dumps(es.search(index=parms[0], size=parms[1], q='*'), indent=4))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Invalid number of arguments. Please enter index name and number of documents.")
            print()

    def do_indices_tail(self, args):
        """
        Show the [number] of recent documents in the index.
        $ indices_head [index] [number] - show the <number> of recent documents in the <index>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index name and number of documents.")
                print()
            else:
                try:
                    print()
                    print(json.dumps(es.search(index=parms[0], size=parms[1], q='*', sort='@timestamp:desc'), indent=4))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Invalid number of arguments. Please enter index name and number of documents.")
            print()

    def do_indices_field_caps(self, args):
        """
        The field capabilities API allows to retrieve the capabilities of fields among multiple indices.
        $ indices_field_caps [field] [index] - show <field> capabilities in <index>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter field and index name.")
                print()
            else:
                try:
                    print()
                    pretty_print(es.field_caps(fields=parms[0], index=parms[1]))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Invalid number of arguments. Please enter field and index name.")
            print()

    def do_indices_field_termvectors(self, args):
        """
        Returns information and statistics on terms in the filed of a particular document.
        $ indices_field_termvectors [index] [doc_type] [doc_id] [field] - returns all information and statistics for
                                                                          field in document.
        """
        if args:
            parms = args.split()
            if len(parms) != 4:
                print()
                print("Invalid number of arguments. Please enter: index, document type, document id and field name.")
                print()
            else:
                try:
                    print()
                    pretty_print(es.termvectors(index=parms[0], doc_type=parms[1], id=parms[2], fields=parms[3],
                                                offsets=True, payloads=True, positions=True, term_statistics=True,
                                                field_statistics=True))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Invalid number of arguments. Please enter: index, document type, document id and field name.")
            print()

    def do_indices_templates(self, args):
        """
        The indices_templates command provides information about existing indices templates.
        $ indices_templates [template_name] - show template information in json format.
        $ indices_templates - show all templates for indices.
        """
        if args:
            try:
                print()
                print(json.dumps(es.indices.get_template(name=args), indent=4))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                print(es.cat.templates(v=True, s="name"))
            except Exception:
                error()

    def do_indices_mapping(self, args):
        """
        Retrieve mapping definition of index or index/type.
        $ indices_mapping [index] - show <index> mapping.
        """
        if args:
            try:
                print()
                pretty = es.indices.get_mapping(index=args)
                print(json.dumps(pretty, indent=4))
                print()
            except Exception:
                error()
        else:
            print("Please provide index name.")

    def complete_indices_mapping(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_field_mapping(self, args):
        """
        Retrieve mapping definition of a specific field.
        $ indices_field_mapping [field] [index] - show <field> mapping in <index>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter field and index name.")
                print()
            else:
                try:
                    print()
                    pretty_print(es.indices.get_field_mapping(fields=parms[0], index=parms[1]))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Invalid number of arguments. Please enter field and index name.")
            print()

    def do_indices_stats_docs(self, args):
        """
        The number of docs / deleted docs (docs not yet merged out). Note, affected by refreshing the index.
        $ indices_stats_docs [index] - show number of docs for <index>.
        $ indices_stats_docs - show number of docs for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="docs", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="docs", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_docs(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_store(self, args):
        """
        Show the size of the indices.
        $ indices_stats_store [index] - show size of <index>.
        $ indices_stats_store - show size of all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="store", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="store", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_store(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_indexing(self, args):
        """
        Show indexing statistics.
        $ indices_stats_indexing [index] - show indexing stats for <index>.
        $ indices_stats_indexing - show indexing stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="indexing", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="indexing", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_indexing(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_get(self, args):
        """
        Get statistics, including missing stats.
        $ indices_stats_get [index] - show get stats for <index>.
        $ indices_stats_get - show get stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="get", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="get", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_get(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_search(self, args):
        """
        Search statistics including suggest statistics.
        $ indices_stats_search [index] - show search stats for <index>.
        $ indices_stats_search - show search stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="search", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="search", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_search(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_segments(self, args):
        """
        Retrieve the memory use of the open segments.
        $ indices_stats_segments [index] - show open segments stats for <index>.
        $ indices_stats_segments - show open segments stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="segments", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="segments", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_segments(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_completion(self, args):
        """
        Show completion suggest statistics.
        $ indices_stats_completion [index] - show completion suggest stats for <index>.
        $ indices_stats_completion - show completion suggest stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="completion", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="completion", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_completion(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_fielddata(self, args):
        """
        Show fielddata statistics.
        $ indices_stats_fielddata [index] - show fielddata stats for <index>.
        $ indices_stats_fielddata - show fielddata stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="fielddata", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="fielddata", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_fielddata(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_flush(self, args):
        """
        Show flush statistics.
        $ indices_stats_flush [index] - show flush stats for <index>.
        $ indices_stats_flush - show flush stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="flush", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="flush", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_flush(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_merge(self, args):
        """
        Show merge statistics.
        $ indices_stats_merge [index] - show merge stats for <index>.
        $ indices_stats_merge - show merge stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="merge", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="merge", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_merge(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_request_cache(self, args):
        """
        Show request cache statistics.
        $ indices_stats_request_cache [index] - show request cache stats for <index>.
        $ indices_stats_request_cache - show request cache stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="request_cache", human=True),
                             indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="request_cache", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_request_cache(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_refresh(self, args):
        """
        Show refresh statistics.
        $ indices_stats_refresh [index] - show refresh stats for <index>.
        $ indices_stats_refresh - show refresh stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="refresh", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="refresh", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_refresh(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_warmer(self, args):
        """
        Show warmer statistics.
        $ indices_stats_warmer [index] - show warmer stats for <index>.
        $ indices_stats_warmer - show warmer stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="warmer", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="warmer", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_warmer(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_stats_translog(self, args):
        """
        Show translog statistics.
        $ indices_stats_translog [index] - show translog stats for <index>.
        $ indices_stats_translog - show translog stats for all indices.
        """
        if args:
            try:
                print()
                pretty_print(es.indices.stats(index=args, level="indices", metric="translog", human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.stats(level="indices", metric="translog", human=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_stats_translog(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_size(self, args):
        """
        Show indices size statistics.
        """
        try:
            index_list = es.cat.indices(h="index,pri.store.size", bytes="b")
            index_temp = []
            for text_line in index_list.split():
                index_temp.append(text_line)
            index_dict = dict(index_temp[i:i + 2] for i in range(0, len(index_temp), 2))
            index_dict = {str(k): int(v) for k, v in index_dict.items()}
            index_sort = sorted(index_dict.items(), key=operator.itemgetter(1))
            almost_1mb = []
            almost_10mb = []
            almost_100mb = []
            almost_1gb = []
            almost_10gb = []
            almost_100gb = []
            almost_other = []
            for item in index_sort:
                if item[1] <= 1000000:
                    almost_1mb.append(item)
                elif item[1] <= 10000000:
                    almost_10mb.append(item)
                elif item[1] <= 100000000:
                    almost_100mb.append(item)
                elif item[1] <= 1000000000:
                    almost_1gb.append(item)
                elif item[1] <= 10000000000:
                    almost_10gb.append(item)
                elif item[1] <= 100000000000:
                    almost_100gb.append(item)
                elif item[1] >= 100000000000:
                    almost_other.append(item)
            print()
            print(
                "i <= 1.MB: {0} | i <= 10.MB: {1} | i <= 100.MB: {2} | i <= 1.GB: {3} | i <= 10.GB: {4} | i <= "
                "100.GB: {5} | i >= 100.GB: {6}".format(
                    str(len(almost_1mb)), str(
                        len(almost_10mb)), str(len(almost_100mb)), str(
                        len(almost_1gb)), str(len(almost_10gb)), str(
                        len(almost_100gb)), str(len(almost_other))))
            print()
        except Exception:
            error()

    def do_indices_settings(self, args):
        """
        Retrieve settings for one or more (or all) indices.
        - indices_settings [index] - show settings for <index>.
        - indices_settings - show settings for all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.indices.get_settings(index=args, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.get_settings(flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_settings(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_status(self, args):
        """
        Show indices state statistics.
        """
        try:
            index_list = es.cat.indices(v=True, h="health")
            rstats = re.compile("red")
            rmatch = rstats.findall(index_list)
            ystats = re.compile("yellow")
            ymatch = ystats.findall(index_list)
            gstats = re.compile("green")
            gmatch = gstats.findall(index_list)
            print("Indices states: RED: {0} YELLOW: {1} GREEN: {2}".format(str(len(rmatch)), str(len(ymatch)), str(
                len(gmatch))))
        except Exception:
            error()

    def do_indices_exists(self, args):
        """
        Return a information indicating whether given index exists.
        $ indices_exists [index] - a name of index to check (default).
        """
        if args:
            print()
            try:
                if es.indices.exists(index=args):
                    print("{0} exists.".format(args))
                    print()
                else:
                    print("{0} don't exists".format(args))
                    print()
            except Exception:
                error()
        else:
            print()
            print("No indices specified.")
            print()

    def complete_indices_exists(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_segments(self, args):
        """
        The segments command is the detailed view of Lucene segments per index.
        $ indices_segments [index] - show segments of the index.
        $ indices_segments  - show segments of all indices (default).
        """
        if args:
            try:
                print()
                less(es.cat.segments(index=args, v=True, s="index"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                less(es.cat.segments(v=True, s="index"))
                print()
            except Exception:
                error()

    def complete_indices_segments(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_segments_verbose(self, args):
        """
        Provide low level segments information that a Lucene index (shard level) is built with.
        $ indices_segments_verbose [index] - show segments of the index.
        $ indices_segments_verbose - show segments off all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.indices.segments(index=args, verbose=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.indices.segments(verbose=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_segments_verbose(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_metadata(self, args):
        """
        Shows the indices metadata part of the response.
        If you supply a comma separated list of indices, the returned
        output will only contain the indices listed.
        $ indices_metadata [index] - show metadata of <index>.
        $ indices_metadata - show metadata of all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.state(metric="metadata", index=args, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.cluster.state(metric="metadata", flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_metadata(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    do_cluster_state_metadata = do_indices_metadata

    def do_indices(self, args):
        """
         The indices command provides a cross-section of each index.
         $ indices [index] - show information about <index>.
         $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args))
            except Exception:
                error()
        else:
            try:
                print()
                less(es.cat.indices(s="index", v=True))
                print()
            except Exception:
                error()

    def complete_indices(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    # TODO
    def do_indices_by(self, args):
        """
        Which index has the largest X sorted by Y?
        $ indices_by docs.count [asc/desc] docs.count - show and sort indices with largest number of documents.

        health                           | h                              | current health status
        status                           | s                              | open/close status
        index                            | i,idx                          | index name
        uuid                             | id,uuid                        | index uuid
        pri                              | p,shards.primary,shardsPrimary | number of primary shards
        rep                              | r,shards.replica,shardsReplica | number of replica shards
        docs.count                       | dc,docsCount                   | available docs
        docs.deleted                     | dd,docsDeleted                 | deleted docs
        creation.date                    | cd                             | index creation date (millisecond value)
        creation.date.string             | cds                            | index creation date (as string)
        store.size                       | ss,storeSize                   | store size of primaries & replicas
        completion.size                  | cs,completionSize              | size of completion
        fielddata.memory_size            | fm,fielddataMemory             | used fielddata cache
        fielddata.evictions              | fe,fielddataEvictions          | fielddata evictions
        query_cache.memory_size          | qcm,queryCacheMemory           | used query cache
        query_cache.evictions            | qce,queryCacheEvictions        | query cache evictions
        request_cache.memory_size        | rcm,requestCacheMemory         | used request cache
        request_cache.evictions          | rce,requestCacheEvictions      | request cache evictions
        request_cache.hit_count          | rchc,requestCacheHitCount      | request cache hit count
        request_cache.miss_count         | rcmc,requestCacheMissCount     | request cache miss count
        flush.total                      | ft,flushTotal                  | number of flushes
        flush.total_time                 | ftt,flushTotalTime             | time spent in flush
        get.current                      | gc,getCurrent                  | number of current get ops
        get.time                         | gti,getTime                    | time spent in get
        get.total                        | gto,getTotal                   | number of get ops
        get.exists_time                  | geti,getExistsTime             | time spent in successful gets
        get.exists_total                 | geto,getExistsTotal            | number of successful gets
        get.missing_time                 | gmti,getMissingTime            | time spent in failed gets
        get.missing_total                | gmto,getMissingTotal           | number of failed gets
        indexing.delete_current          | idc,indexingDeleteCurrent      | number of current deletions
        indexing.delete_time             | idti,indexingDeleteTime        | time spent in deletions
        indexing.delete_total            | idto,indexingDeleteTotal       | number of delete ops
        indexing.index_current           | iic,indexingIndexCurrent       | number of current indexing ops
        indexing.index_time              | iiti,indexingIndexTime         | time spent in indexing
        indexing.index_total             | iito,indexingIndexTotal        | number of indexing ops
        indexing.index_failed            | iif,indexingIndexFailed        | number of failed indexing ops
        merges.current                   | mc,mergesCurrent               | number of current merges
        merges.current_docs              | mcd,mergesCurrentDocs          | number of current merging docs
        merges.current_size              | mcs,mergesCurrentSize          | size of current merges
        merges.total                     | mt,mergesTotal                 | number of completed merge ops
        merges.total_docs                | mtd,mergesTotalDocs            | docs merged
        merges.total_size                | mts,mergesTotalSize            | size merged
        merges.total_time                | mtt,mergesTotalTime            | time spent in merges
        refresh.total                    | rto,refreshTotal               | total refreshes
        refresh.time                     | rti,refreshTime                | time spent in refreshes
        refresh.listeners                | rli,refreshListeners           | number of pending refresh listeners
        search.fetch_current             | sfc,searchFetchCurrent         | current fetch phase ops
        search.fetch_time                | sfti,searchFetchTime           | time spent in fetch phase
        search.fetch_total               | sfto,searchFetchTotal          | total fetch ops
        search.open_contexts             | so,searchOpenContexts          | open search contexts
        search.query_current             | sqc,searchQueryCurrent         | current query phase ops
        search.query_time                | sqti,searchQueryTime           | time spent in query phase
        search.query_total               | sqto,searchQueryTotal          | total query phase ops
        search.scroll_current            | scc,searchScrollCurrent        | open scroll contexts
        search.scroll_time               | scti,searchScrollTime          | time scroll contexts held open
        search.scroll_total              | scto,searchScrollTotal         | completed scroll contexts
        segments.count                   | sc,segmentsCount               | number of segments
        segments.memory                  | sm,segmentsMemory              | memory used by segments
        segments.index_writer_memory     | siwm,segmentsIndexWriterMemory | memory used by index writer
        segments.version_map_memory      | svmm,segmentsVersionMapMemory  | memory used by version map
        segments.fixed_bitset_memory     | sfbm,fixedBitsetMemory         | memory used by fixed bit sets for nested
                                                                            object field types and type filters for
                                                                            types referred in _parent fields
        warmer.current                   | wc,warmerCurrent               | current warmer ops
        warmer.total                     | wto,warmerTotal                | total warmer ops
        warmer.total_time                | wtt,warmerTotalTime            | time spent in warmers
        suggest.current                  | suc,suggestCurrent             | number of current suggest ops
        suggest.time                     | suti,suggestTime               | time spend in suggest
        suggest.total                    | suto,suggestTotal              | number of suggest ops
        memory.total                     | tm,memoryTotal                 | total used memory
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter value to sort [asc/desc] and value to display.")
                print()
            else:
                try:
                    print()
                    less(es.cat.indices(s=parms[0] + ":" + parms[1], v=True, h="index," + parms[2]))
                except Exception:
                    error()
        else:
            print()
            print("Please enter value to sort on [asc/desc] and value to display. Use help for possible values.")
            print()

    def do_indices_green(self, args):
        """
        The indices_green command provides a cross-section of each index in green health status.
        $ indices [index] - show information about <index>.
        $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args, health="green"))
            except Exception:
                error()
        else:
            try:
                print()
                print(es.cat.indices(s="index", v=True, health="green"))
            except Exception:
                error()

    def complete_indices_green(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_yellow(self, args):
        """
        The indices_yellow command provides a cross-section of each index in yellow health status.
        $ indices [index] - show information about <index>.
        $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args, health="yellow"))
            except Exception:
                error()
        else:
            try:
                print()
                print(es.cat.indices(s="index", v=True, health="yellow"))
            except Exception:
                error()

    def complete_indices_yellow(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_red(self, args):
        """
        The indices_red command provides a cross-section of each index in red health status.
        $ indices [index] - show information about <index>.
        $ indices - show information about all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.indices(s="index", v=True, index=args, health="red"))
            except Exception:
                error()
        else:
            try:
                print()
                print(es.cat.indices(s="index", v=True, health="red"))
            except Exception:
                error()

    def complete_indices_red(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_aliases(self, args):
        """
        Shows information about currently configured aliases to indices including filter and routing info.
        $ indices_aliases [alias] - <alias> name to return from aliases.
        $ indices_aliases - show all aliases (default).
        """
        if args:
            try:
                print()
                print(es.cat.aliases(name=args, v=True))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                print(es.cat.aliases(s="alias", v=True))
                print()
            except Exception:
                error()

    def do_indices_documents(self, args):
        """
        Count provides quick access to the document count of the entire cluster, or individual indices.
        The document count indicates the number of live documents and does not include deleted documents
        which have not yet been cleaned up by the merge process.
        $ indices_documents [index] - document count in <index>.
        $ indices_documents - document count for all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.count(index=args, v=True))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                print(es.cat.count(v=True))
                print()
            except Exception:
                error()

    def complete_indices_documents(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_routing_table(self, args):
        """
        Shows indices the routing table part of the response.
        If you supply a comma separated list of indices, the returned
        output will only contain the indices listed.
        $ indices_routing_table [index] - show routing_table of <index>.
        $ indices_routing_table - show routing_table of all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.state(metric="routing_table", index=args, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.cluster.state(metric="routing_table", flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_routing_table(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    do_cluster_state_routing_table = do_indices_routing_table

    def do_indices_health(self, args):
        """
        Get a very simple status on the health of the indices.
        $ indices_health [index] - show health of <index>.
        $ indices_health - show health of all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.health(level="indices", index=args), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.cluster.health(level="indices"), indent=2)
                print()
            except Exception:
                error()

    def complete_indices_health(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_search_shards(self, args):
        """
        Returns the indices and shards that a search request would be executed against.
        $ indices_search_shards [index] - show which shards will be searched for <index>.
        $ indices_search_shards - show which shards will be searched for all indices (default).
        """
        if args:
            try:
                print()
                print(json.dumps(es.search_shards(index=args), indent=4))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                print(json.dumps(es.search_shards(), indent=4))
                print()
            except Exception:
                error()

    # Elasticsearch shards
    def do_shards(self, args):
        """
        The shards command is the detailed view of what nodes contain which shards.
        $ shards [index] - show shards of <index>.
        $ shards - show shards of all indices (default).
        """
        if args:
            try:
                print()
                print(es.cat.shards(index=args, v=True, s="node"))
            except Exception:
                error()
        else:
            try:
                print()
                less(es.cat.shards(v=True))
                print()
            except Exception:
                error()

    def complete_shards(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_store(self, args):
        """
        Provides store information for shard copies of indices. Store information reports on which
        nodes shards copies exist, the shard copy version, indicating how recent the are, and any
        exceptions encountered while opening the shard index or from earlier engine failure.
        $ shards_store [index] [red|yellow|green] - show shards store information about <index>.
        $ shards_store - show shards store information about all indices.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and its status.")
                print()
            else:
                try:
                    print()
                    print(json.dumps(es.indices.shard_stores(index=parms[0], status=parms[1]), indent=4))
                    print()
                except Exception:
                    error()
        else:
            try:
                print()
                print(json.dumps(es.indices.shard_stores(index="_all", status="all"), indent=4))
                print()
            except Exception:
                error()

    def complete_shards_store(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_unassigned(self, args):
        """
        List unassigned shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "UNASSIGNED" in line:
                print(line)
        print()

    def do_shards_relocating(self, args):
        """
        List relocating shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "RELOCATING" in line:
                print(line)
        print()

    def do_shards_initializing(self, args):
        """
        List initializing shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "INITIALIZING" in line:
                print(line)
        print()

    def do_shards_started(self, args):
        """
        List started shards.
        """
        shard_list = es.cat.shards(v=True)
        print()
        print(shard_list.split("\n")[0])
        for line in shard_list.split("\n"):
            if "STARTED" in line:
                print(line)
        print()

    def do_shards_recovery(self, args):
        """
        Recovery is a view of shard replication.
        $ shards_recovery [index] - show recovery status of the <index>.
        $ shards_recovery - show recovery status of all indices (default).

          index                  | idx   | index name
          shard                  | sh    | shard name
          time                   | ti    | recovery time
          type                   | ty    | recovery type
          stage                  | st    | recovery stage
          source_host            | shost | source host
          source_node            | snode | source node name
          target_host            | thost | target host
          target_node            | tnode | target node name
          repository             | rep   | repository
          snapshot               | snap  | snapshot
          files                  | f     | number of files to recover
          files_recovered        | fr    | files recovered
          files_percent          | fp    | percent of files recovered
          files_total            | tf    | total number of files
          bytes                  | b     | number of bytes to recover
          bytes_recovered        | br    | bytes recovered
          bytes_percent          | bp    | percent of bytes recovered
          bytes_total            | tb    | total number of bytes
          translog_ops           | to    | number of translog ops to recover
          translog_ops_recovered | tor   | translog ops recovered
          translog_ops_percent   | top   | percent of translog ops recovered
        """
        if args:
            try:
                print()
                print(es.cat.recovery(index=args, v=True, s="index",
                                      h="idx,sh,ti,ty,st,shost,snode,thost,tnode,rep,snap,f,fr,fp,tf,b,br,bp,tb,to,"
                                        "tor,top"))
            except Exception:
                error()
        else:
            try:
                print()
                less(es.cat.recovery(v=True, s="index",
                                     h="idx,sh,ti,ty,st,shost,snode,thost,tnode,rep,snap,f,fr,fp,tf,b,br,bp,tb,to,"
                                       "tor,top"))
                print()
            except Exception:
                error()

    def complete_shards_recovery(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_health(self, args):
        """
        Get a very simple status on the health of the indices shards.
        $ indices_health [index] - show health of index <shards>.
        $ indices_health - show health of shards in all indices (default).
        """
        if args:
            try:
                print()
                pretty_print(es.cluster.health(level="shards", index=args), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.cluster.health(level="shards"), indent=2)
                print()
            except Exception:
                error()

    def complete_shards_health(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    # Elasticsearch nodes
    def do_nodes_usage(self, args):
        """
        The cluster nodes usage API allows to retrieve information on the usage
        of features for each node.
        $ nodes_usage [node_id] - show information on the usage of <node>.
        $ nodes_usage - show information on the usage of all nodes.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.usage(node_id=args, human=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.usage(human=True), indent=2)
                print()
            except Exception:
                error()

    def do_nodes_plugins(self, args):
        """
        The plugins command provides a view per nodes of running plugins.
        """
        try:
            print()
            print(es.cat.plugins(v=True, s="node", h="name,component,version,description"))
        except Exception:
            error()

    def do_nodes_settings(self, args):
        """
        Retrieves information about node(s) settings in the cluster.
        $ nodes_settings [node_id|name] - show <node> settings.
        $ node_settings - show all the nodes settings in the cluster (default).

          - build_hash - sort of the last git commit in this release.
          - host - the node's host name.
          - http_address - host and port where primary HTTP connections are accepted.
          - ip - the node's ip address.
          - name - the nodes name.
          - transport_address - host and port where transport HTTP connections are accepted.
          - version - elasticsearch version running on this node.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="settings", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="settings", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_nodes_settings(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_os(self, args):
        """
        Retrieve node(s) information that concern the operating system.
        $ nodes_info_os [node_id|name] - show node os information.
        $ nodes_info_os - show os information for all the nodes (default).

          - os.refresh_interval_in_millis - refresh interval for the OS statistics.
          - os.name - name of the operating system (Linux / Windows / Mac OS X).
          - os.arch - name of the JVM architecture (amd64, x86).
          - os.version - version of the operating system.
          - os.available_processors - number of processors available to the Java virtual machine.
          - os.allocated_processors - the number of processors actually used to calculate thread
            pool size. This number can be set with the "processors" setting of a node and defaults
            to the number of processors reported by the OS. In both cases this number will never be
            larger than 32.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="os", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="os", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_nodes_info_os(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_process(self, args):
        """
        Retrieve node(s) information that concern the current running ElasticSearch process.
        $ node_info_process [node_id|name] - show node ES process information.
        $ node_info_process - show ES process information for all the nodes (default).

          - process.refresh_intervel_in_millis - refresh interval for the process statistics.
          - process.id - process identifier (PID).
          - process.mlockall - indicates if the process address space has been successfully locked in memory.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="process", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="process", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_nodes_info_process(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_jvm(self, args):
        """
        Show information about node JVM: GC collectors, arguments, heap, version etc.
        $ nodes_info_jvm [node_id] - info about one <node>.
        $ nodes_info_jvm - info about all nodes.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="jvm", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="jvm", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_nodes_info_jvm(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_thread_pool(self, args):
        """
        Show summary information about node thread pools.
        $ nodes_info_thread_pool [node_id] - info about one <node>.
        $ nodes_info_thread_pool - info about all nodes.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="thread_pool", human=True, flat_settings=True),
                             indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="thread_pool", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_nodes_info_thread_pool(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_transport(self, args):
        """
        Show information about transport address and port.
        $ nodes_info_transport [node_id] - info about one <node>.
        $ nodes_info_transport - info about all nodes.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="transport", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="transport", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_nodes_info_transport(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_http(self, args):
        """
        Show information about http address and port.
        $ nodes_info_http [node_id] - info about one <node>.
        $ nodes_info_http - info about all nodes.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="http", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="http", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_nodes_info_http(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_plugins(self, args):
        """
        Result will contain details about the loaded plugins per node.
        $ node_info_plugins [node_id|name] - show <node> ES plugins information.
        $ node_info_plugins - show ES plugins information for all the nodes (default).

          - plugins.name - plugin name.
          - plugins.description - plugin description if any.
          - plugins.site - true if the plugin is a site plugin.
          - plugins.jvm - true if plugin is a plugin running in the JVM.
          - plugins.url - URL if the plugin is a site plugin.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="plugins", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="plugins", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_nodes_info_plugins(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_ingest(self, args):
        """
        Result will contain details about the available processors per node.
        $ node_info_ingest [node_id|name] - show <node> ES ingest information.
        $ node_info_ingest - show ES ingest information for all the nodes (default).

          - processors.type - the processor type.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="ingest", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="ingest", human=True, flat_settings=True), indent=2)
                print()
            except Exception:
                error()

    def complete_nodes_info_ingest(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_info_indexing_buffer(self, args):
        """
        Result will contain details about heap used for indexing process.
        $ node_info_indexing_buffer [node_id|name] - show <node> ES indexing heap information.
        $ node_info_indexing_buffer - show ES indexing heap information for all the nodes (default).

          - total_indexing_buffer - total heap allowed to be used to hold recently indexed documents before
            they must be written do disk. This size is a shared pool across all shards on this node, and is
            controlled by Indexing Buffer settings (indices.memory.index_buffer_size).
          - total_indexing_buffer_in_bytes - same as total_indexing_buffer but expressed in bytes.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.info(node_id=args, metric="indices", human=True, flat_settings=True))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.info(metric="indices", human=True, flat_settings=True))
                print()
            except Exception:
                error()

    def complete_nodes_info_indexing_buffer(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_indices(self, args):
        """
        Show indices stats about size, document count, indexing and deletion times, search times,
        field cache size, merges and flushes.
        $ node_stats_indices [node_id|name] - show node ES indices stats.
        $ node_stats_indices - show ES indices stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="indices", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="indices", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_indices(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_fs(self, args):
        """
        Show file system information, data path, free disk space, read/write stats.
        $ nodes_stats_fs [node_id|name] - show <node> ES fs stats.
        $ nodes_stats_fs - show node ES fs stats for all the nodes (default).

          - fs.timestamp - last time the file stores statistics have been refreshed.
          - fs.total.total_in_bytes - total size (in bytes) of all file stores.
          - fs.total.free_in_bytes - total number of unallocated bytes in all file stores.
          - fs.total.available_in_bytes - total number of bytes available to this Java virtual machine on all
            file stores.
          - fs.data - list of all file stores.
          - fs.data.path - path to the file store.
          - fs.data.mount - mount point of the file store (ex: /dev/sda2)
          - fs.data.type - type of the file store (ex: ext4)
          - fs.data.total_in_bytes - total size (in bytes) of the file store.
          - fs.data.free_in_bytes - total number of unallocated bytes in the file store.
          - fs.data.available_in_bytes - total number of bytes available to this Java virtual machine on this
            file store.
          - fs.data.spins - indicates if the store is backed by spinning storage.
            null means we cloud not determine it.
            true means the device possible spins.
            false means it does not (ex: solid-state disk)
          - fs.io_stats.devices - array of disk metrics for each device that is backing an Elasticsearch data path.
            These disk metrics are probed periodically and averages between the last probe and the current probe are
            computed.
          - fs.io_stats.devices.device_name - the Linux device name.
          - fs.io_stats.devices.operations - the total number of read and write operations for the device completed
            since starting Elasticsearch.
          - fs.io_stats.devices.read_operations - the total number of read operations for the device completed since
            starting Elasticsearch.
          - fs.io_stats.devices.write_operations - the total number of write operations for the device completed since
            starting Elasticsearch.
          - fs.io_stats.devices.read_kilobytes - the total number of kilobytes read for the device since starting
            Elasticsearch.
          - fs.io_stats.devices.write_kilobytes - the total number of kilobytes written for the device since starting
            Elasticsearch.
          - fs.io_stats.operations - the total number of read and write operations across all devices used by
            Elasticsearch completed since starting Elasticsearch.
          - fs.io_stats.read_operations - the total number of read operations for across all devices used by
            Elasticsearch completed since starting Elasticsearch.
          - fs.io_stats.write_operations - the total number of write operations across all devices used by
            Elasticsearch completed since starting Elasticsearch.
          - fs.io_stats.read_kilobytes - the total number of kilobytes read across all devices used by Elasticsearch
            since starting Elasticsearch.
          - fs.io_stats.write_kilobytes - the total number of kilobytes written across all devices used by Elasticsearch
            since starting Elasticsearch.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="fs", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="fs", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_fs(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_http(self, args):
        """
        Show HTTP connection information.
        $ node_stats_http [node_id|name] - show <node> ES HTTP stats.
        $ node_stats_http - show ES HTTP stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="http", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="http", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_http(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_jvm(self, args):
        """
        Show JVM stats, memory pool information, garbage collection, buffer pools, number of loaded/unloaded classes.
        $ node_stats_jvm [node_id|name] - show node ES JVM stats.
        $ node_stats_jvm - show ES JVM stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="jvm", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="jvm", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_jvm(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_os(self, args):
        """
        Show operating system stats, load average, mem, swap.
        $ node_stats_os [node_id|name] - show <node> ES OS stats.
        $ node_stats_os - show ES OS stats for all the nodes (default).

          - os.timestamp - last time the operating system statistics have been refreshed.
          - os.cpu.percent - recent CPU usage for the whole system, or -1 if not supported.
          - os.cpu.load_average.1m - one-minute load average on the system (field is not present if one-minute load
            average is not available).
          - os.cpu.load_average.5m - five-minute load average on the system (field is not present if five-minute
            load average is not available).
          - os.cpu.load_average.15m - fifteen-minute load average on the system (field is not present if fifteen-minute
            load average is not available).
          - os.mem.total_in_bytes - total amount of physical memory in bytes.
          - os.mem.free_in_bytes - amount of free physical memory in bytes.
          - os.mem.free_percent - percentage of free memory.
          - os.mem.used_in_bytes - amount of used physical memory in bytes.
          - os.mem.used_percent - percentage of used memory.
          - os.swap.total_in_bytes - total amount of swap space in bytes.
          - os.swap.free_in_bytes - amount of free swap space in bytes.
          - os.swap.used_in_bytes - amount of used swap space in bytes.
          - os.cgroup.cpuacct.control_group - the cpuacct control group to which the Elasticsearch process belongs.
          - os.cgroup.cpuacct.usage_nanos - the total CPU time (in nanoseconds) consumed by all tasks in the same cgroup
            as the Elasticsearch process.
          - os.cgroup.cpu.control_group - the cpu control group to which the Elasticsearch process belongs.
          - os.cgroup.cpu.cfs_period_micros - the period of time (in microseconds) for how regularly all tasks in the
            same cgroup as the Elasticsearch process should have their access to CPU resources reallocated.
          - os.cgroup.cpu.cfs_quota_micros - the total amount of time (in microseconds) for which all tasks in the same
            cgroup as the Elasticsearch process can run during one period os.cgroup.cpu.cfs_period_micros.
          - os.cgroup.cpu.stat.number_of_elapsed_periods - the number of reporting periods (as specified by
            os.cgroup.cpu.cfs_period_micros) that have elapsed.
          - os.cgroup.cpu.stat.number_of_times_throttled - the number of times all tasks in the same cgroup as
            the Elasticsearch process have been throttled.
          - os.cgroup.cpu.stat.time_throttled_nanos - the total amount of time (in nanoseconds) for which all tasks in
            the same cgroup as the Elasticsearch process have been throttled.
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="os", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="os", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_os(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_process(self, args):
        """
        Show process statistics, memory consumption, cpu usage, open file descriptors.
        $ node_stats_process [node_id|name] - show <node> ES process stats.
        $ node_stats_process - show ES process stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="process", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="process", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_process(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_thread_pool(self, args):
        """
        Show statistics about each thread pool, including current size, queue and rejected tasks.
        $ node_stats_thread_pool [node_id|name] - show <node> ES threads stats.
        $ node_stats_thread_pool - show ES threads stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="thread_pool", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="thread_pool", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_thread_pool(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_transport(self, args):
        """
        Show statistics about send and received bytes in cluster communication.
        $ node_stats_transport [node_id|name] - show <node> ES transport stats.
        $ node_stats_transport - show ES transport stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="transport", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="transport", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_transport(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_breaker(self, args):
        """
        Show statistics about the field data circuit breaker.
        $ node_stats_breaker [node_id|name] - show <node> ES breaker stats.
        $ node_stats_breaker - show ES transport stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="breaker", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="breaker", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_breaker(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_discovery(self, args):
        """
        Show statistics about the discovery.
        $ node_stats_discovery [node_id|name] - show <node> ES discovery stats.
        $ node_stats_discovery - show ES discovery stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="discovery", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="discovery", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_discovery(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_ingest(self, args):
        """
        Show statistics about ingest preprocessing.
        $ node_stats_ingest [node_id|name] - show <node> ES ingest stats.
        $ node_stats_ingest - show ES ingest stats for all the nodes (default).
        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="ingest", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="ingest", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_ingest(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_stats_adaptive_selection(self, args):
        """
        Show statistics about adaptive replica selection.
        $ node_stats_adaptive_selection [node_id|name] - show <node> ES adaptive replica selection stats.
        $ node_stats_adaptive_selection - show ES adaptive replica selection stats for all nodes (default).

          - outgoing_searches - the number of outstanding search requests from the node these stats are for to the
            keyed node.
          - avg_queue_size - the exponentially weighted moving average queue size of search requests on the keyed node.
          - avg_service_time_ns - the exponentially weighted moving average service time of search requests on the
            keyed node.
          - avg_response_time_ns - the exponentially weighted moving average response time of search requests on the
            keyed node.
          - rank - the rank of this node; used for shard selection when routing search requests.

        """
        if args:
            try:
                print()
                pretty_print(es.nodes.stats(node_id=args, metric="adaptive_selection", human=True, level="node"))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                pretty_print(es.nodes.stats(metric="adaptive_selection", human=True, level="node"))
                print()
            except Exception:
                error()

    def complete_nodes_stats_adaptive_selection(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    def do_nodes_allocation(self, args):
        """
        Allocation provides a snapshot of how shards have located around the cluster and the state of disk usage.
        $ nodes_allocation [node_id|name] - show <node> shards allocation.
        $ nodes_allocation - show shards allocation for all the nodes (default).
        """
        if args:
            try:
                print()
                print(es.cat.allocation(node_id=args, v=True))
            except Exception:
                error()
        else:
            try:
                print()
                print(es.cat.allocation(s="node", v=True))
            except Exception:
                error()

    def complete_nodes_allocation(self, text, line, begidx, endidx):
        return [i for i in nodelist() if i.startswith(text)]

    do_nodes_disk = do_nodes_allocation

    def do_nodes_cat_disk_space(self, args):
        """
        Shows nodes available disk space.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,disk", v=True))
        except Exception:
            error()

    def do_nodes_fielddata(self, args):
        """
        Shows information about currently loaded fielddata on a per-node basis.
        $ nodes_fielddata [field] - show fielddata size for individual <field>.
        $ nodes_fielddata - shows how much heap memory is currently being used by
          fielddata on every data node in the cluster (default).

        """
        if args:
            try:
                print()
                print(es.cat.fielddata(s="node", v=True, bytes="mb", fields=args))
            except Exception:
                error()
        else:
            try:
                print()
                print(es.cat.fielddata(s="node", v=True, bytes="mb"))
            except Exception:
                error()

    def do_nodes_attributes(self, args):
        """
        Shows custom node attributes.
        """
        try:
            print()
            print(es.cat.nodeattrs(s="node", v=True))
        except Exception:
            error()

    def do_nodes_cat_id(self, args):
        """
        Shows nodes uniq ids.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,id", full_id=True, v=True))
        except Exception:
            error()

    def do_nodes_cat_ports(self, args):
        """
        Shows nodes bound ip, transport and http address.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,port,http_address", v=True))
        except Exception:
            error()

    def do_nodes_cat_version(self, args):
        """
        Shows nodes Elasticsearch version, build hash and running java version.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,version,build,jdk", v=True))
        except Exception:
            error()

    def do_nodes_cat_heap(self, args):
        """
        Shows nodes used and maximum configured heap.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,heap.current,heap.percent,heap.max", v=True))
        except Exception:
            error()

    def do_nodes_cat_ram(self, args):
        """
        Shows nodes used and total memory.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,ram.current,ram.percent,ram.max", v=True))
        except Exception:
            error()

    def do_nodes_cat_filedesc(self, args):
        """
        Shows nodes used and maximum number of file descriptors.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,file_desc.current,file_desc.percent,file_desc.max", v=True))
        except Exception:
            error()

    def do_nodes_cat_load(self, args):
        """
        Shows nodes recent system CPU usage.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,cpu,load_1m,load_5m,load_15m", v=True))
        except Exception:
            error()

    def do_nodes_cat_uptime(self, args):
        """
        Shows nodes uptime.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,uptime", v=True))
        except Exception:
            error()

    def do_nodes_cat_role(self, args):
        """
        Shows nodes role.
        - m - master eligible node.
        - d - data node.
        - i - ingest node.
        - - - coordinating node only.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,node.role,master", v=True))
        except Exception:
            error()

    def do_nodes_cat_completion(self, args):
        """
        Shows nodes size of completion.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,completionSize", v=True))
        except Exception:
            error()

    def do_nodes_cat_fielddata_and_evictions(self, args):
        """
        Shows used fielddata cache memory and evictions.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,fielddataMemory,fielddataEvictions", v=True))
        except Exception:
            error()

    def do_nodes_cat_query_cache_and_evictions(self, args):
        """
        Shows used query cache memory and evictions.
        """
        try:
            print()
            print(es.cat.nodes(s="name", h="name,ip,id,queryCacheMemory,queryCacheEvictions", v=True))
        except Exception:
            error()

    def do_nodes_cat_request_cache_and_evictions(self, args):
        """
        Shows used request cache memory, evictions, hit and miss count.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,requestCacheMemory,requestCacheEvictions,requestCacheHitCount,"
                                 "requestCacheMissCount",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_flush(self, args):
        """
        Shows number of flushes and time spent in flush.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,flushTotal,flushTotalTime",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_get(self, args):
        """
        Shows number of current and total get operations, time spent in gets and others.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,getCurrent,getTime,getTotal,getExistsTime,getExistsTotal,getMissingTime,"
                                 "getMissingTotal",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_delete(self, args):
        """
        Shows number of current and total delete operations, time spent in deletions.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,indexingDeleteCurrent,indexingDeleteTime,indexingDeleteTotal",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_indexing(self, args):
        """
        Shows number of current and total index operations, time spent in indexing.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,indexingIndexCurrent,indexingIndexTime,indexingIndexTotal,"
                                 "indexingIndexFailed",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_merges(self, args):
        """
        Shows number of current and total mege operations, time spent in merging.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,mergesCurrent,mergesCurrentDocs,mergesCurrentSize,mergesTotal,"
                                 "mergesTotalDocs,mergesTotalSize,mergesTotalTime",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_refresh(self, args):
        """
        Shows number of refreshes and time spent in refreshes.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,refreshTotal,refreshTime",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_script(self, args):
        """
        Shows total script compilations and compiled scripts evicted from cache.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,scriptCompilations,scriptCacheEvictions",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_search(self, args):
        """
        Shows open search contexts.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchOpenContexts",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_search_fetch(self, args):
        """
        Shows current fetch phase operations and time spent in fetch phase.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchFetchCurrent,searchFetchTime,searchFetchTotal",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_search_query(self, args):
        """
        Shows current query phase operations and time spent in query phase.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchQueryCurrent,searchQueryTime,searchQueryTotal",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_search_scroll(self, args):
        """
        Shows current open scroll contexts and time scroll contexts held open.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,searchScrollCurrent,searchScrollTime,searchScrollTotal",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_segments(self, args):
        """
        Shows number of segments and memory used by segments.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,segmentsCount,segmentsMemory,segmentsIndexWriterMemor,"
                                 "segmentsVersionMapMemory,fixedBitsetMemory",
                               v=True))
        except Exception:
            error()

    def do_nodes_cat_suggest(self, args):
        """
        Shows number current suggest operations and time spent in suggest.
        """
        try:
            print()
            print(es.cat.nodes(s="name",
                               h="name,ip,id,suggestCurrent,suggestTime,suggestTotal",
                               v=True))
        except Exception:
            error()

    def do_nodes_thread_pool_write(self, args):
        """
        Show current settings and status of threads for write operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="write", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_bulk(self, args):
        """
        Show current settings and status of threads for bulk operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="bulk", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_analyze(self, args):
        """
        Show current settings and status of threads for analyze operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="analyze", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_generic(self, args):
        """
        Show current settings and status of threads for generic (e.g., background node discovery) operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="generic", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_index(self, args):
        """
        Show current settings and status of threads for index / delete operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="index", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_search(self, args):
        """
        Show current settings and status of threads for count / search / suggest operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="search", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_get(self, args):
        """
        Show current settings and status of threads for get operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="get", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_percolate(self, args):
        """
        Show current settings and status of threads for percolate operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="percolate", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_snapshot(self, args):
        """
        Show current settings and status of threads for snapshot / restore operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="snapshot", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_warmer(self, args):
        """
        Show current settings and status of threads for segment warm-up operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="warmer", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_refresh(self, args):
        """
        Show current settings and status of threads for refresh operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="refresh", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_listener(self, args):
        """
        Show current settings and status of threads for java client executing action operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="listener", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_management(self, args):
        """
        Show current settings and status of threads management operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="management", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_force_merge(self, args):
        """
        Show current settings and status of threads force merge / optimize operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="force_merge", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_flush(self, args):
        """
        Show current settings and status of threads flush operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="flush", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_fetch_shard_started(self, args):
        """
        Show current settings and status of threads starting shard operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="fetch_shard_started", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_thread_pool_fetch_shard_store(self, args):
        """
        Show current settings and status of threads storing shard operations.
        """
        try:
            print()
            print(es.cat.thread_pool(v=True, thread_pool_patterns="fetch_shard_store", s="node_name",
                                     h="node_name,name,type,active,size,queue,queue_size,rejected,largest,completed,"
                                       "min,max,keep_alive"))
        except Exception:
            error()

    def do_nodes_hot_threads(self, args):
        """
        Shows the current hot threads on each node in the cluster.
        $ nodes_hot_threads [threads_no] [cpu|wait|block] [node id]- the type to sample to see number of hot threads.
        $ nodes_hot_threads - show top 5 hot threads in cpu type for all nodes.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter number of threads, type and node id.")
                print()
            else:
                try:
                    print()
                    print(es.nodes.hot_threads(threads=parms[0], type=parms[1], node_id=parms[2]))
                    print()
                except Exception:
                    error()
        else:
            try:
                print()
                print(es.nodes.hot_threads(threads="5", type="cpu", node_id="_all"))
            except Exception:
                error()

    def do_nodes_tasks(self, args):
        """
        Show tasks currently executing on one or mode nodes in the cluster.
        $ nodes_tasks [task_id] - show info about particular task.
        $ nodes_tasks - retrieves all tasks currently running on all nodes in the cluster (default).
        """

        if args:
            try:
                print()
                print(json.dumps(es.tasks.get(task_id=args), indent=4))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                print(es.cat.tasks(v=True, detailed=True, s="node"))
            except Exception:
                error()

    def do_nodes_tasks_by_action(self, args):
        """
        Retrieves all tasks currently running on all nodes in the cluster filtered by action.
        eg: cluster*, indices*, *search, *bulk, *reindex etc.
        $ nodes_tasks_by_action cluster* - retrieves all cluster-related tasks running on all nodes.
        """
        if args:
            parms = args.split()
            if len(parms) != 1:
                print()
                print("Invalid number of arguments. Please enter action name.")
                print()
            else:
                try:
                    print()
                    pretty_print(es.tasks.list(detailed=True, group_by="nodes", actions=args), indent=2)
                    print()
                except Exception:
                    error()
        else:
            try:
                print()
                pretty_print(es.tasks.list(detailed=True, group_by="nodes"), indent=2)
                print()
            except Exception:
                error()

    def do_nodes_tasks_by_node(self, args):
        """
        Retrieves all tasks currently running on specified nodes in the cluster.
        $ nodes_tasks_by_node [node_id] - retrieves all tasks running on node <node_id>
        """
        if args:
            parms = args.split()
            if len(parms) != 1:
                print()
                print("Invalid number of arguments. Please enter node id.")
                print()
            else:
                try:
                    print()
                    pretty_print(es.tasks.list(detailed=True, group_by="nodes", nodes=args), indent=2)
                    print()
                except Exception:
                    error()
        else:
            try:
                print()
                pretty_print(es.tasks.list(detailed=True, group_by="nodes"), indent=2)
                print()
            except Exception:
                error()


class Exec(cmd.Cmd):
    intro = "{0}\n### Entering to cluster execution menu!\n### For more information, type \"help\" or \"?\".\n{1}". \
        format(BColors.BOLD, BColors.ENDC)
    prompt = "es:exec~$ "
    ruler = "-"
    doc_header = "Available commands (type: help <command>):"

    def default(self, line):
        """
        Called on an input line when the command prefix is not recognized.
        In that case we execute the line as Python code.
        """
        try:
            exec(line) in self._locals, self._globals
        except NameError:
            print("Command {0} not found.".format(line))
        except SyntaxError:
            print("Invalid command syntax.")
        except KeyboardInterrupt:
            print("Detected Ctrl+D. Exiting...")
        except Exception as e:
            print("{0} : {1}".format(e.__class__, e))

    def preloop(self):
        """
        Initialization before prompting user for commands.
        """
        cmd.Cmd.preloop(self)
        self._history = []
        self._locals = {}
        self._globals = {}

    def precmd(self, line):
        """
        This method is called after the line has been input but before
        it has been interpreted. If you want to modifdy the input line
        before execution (for example, variable substitution) do it here.
        """
        self._history += [line.strip()]
        return line

    def postloop(self):
        """
        Take care of any unfinished business.
        """
        cmd.Cmd.postloop(self)
        print("Exiting...")

    def postcmd(self, stop, line):
        """
        If you want to stop the console, return something that evaluates to true.
        If you want to do some post command processing, do it here.
        """
        return stop

    def emptyline(self):
        """
        Do nothing on empty line input.
        """
        pass

    def do_prompt(self, args):
        """
        Change console prompt.
        $ prompt [new prompt] - set new prompt.
        """
        self.prompt = "{0}:~$ ".format(args)

    def do_help(self, args):
        """
        Get help on commands:
        'help' or '?' with no arguments prints a list of commands for which help is available
        'help <command>' or '? <command>' gives help on <command>
        """
        cmd.Cmd.do_help(self, args)

    def do_history(self, args):
        """
        Print a list of commands that have been entered into console.
        """
        print(self._history)

    def do_clear(self, args):
        """
        Clear the screen.
        """
        os.system("clear")

    def do_shell(self, line):
        """
        Pass command to a system shell when line begins with '!'
        """
        print("Running shell command: {0}\n".format(line))
        sub_cmd = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE)
        output = sub_cmd.communicate()[0].decode("utf-8")
        print(output)
        self.last_output = output

    def do_echo(self, line):
        """
        Print the input, replacing '$out' with the output of the last shell command.
        """
        print(line.replace("$out", self.last_output))

    def do_quit(self, args):
        """
        Quits from the console.
        """
        return True

    def do_exit(self, args):
        """
        Exits from the console.
        """
        return True

    def do_EOF(self, line):
        """
        Exit on system end of file character (Ctrl+D).
        """
        return True

    def do_leave(self, line):
        """
        Leave submenu.
        """
        return True

    def do_show(self, line):
        """Execute command in cluster information menu."""
        Show().onecmd(line)

    def complete_show(self, text, line, begidx, endidx):
        return [i for i in commandlist(Show()) if i.startswith(text)]

    # Elasticsearch cluster
    def do_cluster_reroute_retry_field_shards(self, args):
        """
        Retries allocation of shards that are blocked due to too many subsequent allocation failures.
        """
        print()
        print(es.cluster.reroute(master_timeout="300s", retry_failed=True))
        print()

    def do_cluster_settings_transient(self, args):
        """
        Update cluster wide specific settings.
        Resetting transient settings can be done by assigning a 'null' value. Strings must be in " ".
        $ cluster_settings_transient [setting] [value] - change cluster transient <setting> to new <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter setting and its value.")
                print()
            else:
                try:
                    setme = '{{ "transient": {{ "{0}" : {1} }} }}'.format(str(parms[0]), str(parms[1]))
                    print()
                    print("Setting: " + setme)
                    print()
                    es.cluster.put_settings(body=setme, flat_settings=True, timeout="300s")
                except Exception:
                    error()
        else:
            try:
                print()
                print("Please enter setting and its value.")
                print()
            except Exception:
                error()

    def do_cluster_settings_persistent(self, args):
        """
        Update cluster wide specific settings.
        Resetting persistent settings can be done by assigning a 'null' value. String must be in " ".
        $ cluster_settings_persistent [setting] [value] - change cluster persistent <setting> to new <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter setting and its value.")
                print()
            else:
                try:
                    setme = '{{ "persistent": {{ "{0}" : {1} }} }}'.format(str(parms[0]), str(parms[1]))
                    print()
                    print("Setting: " + setme)
                    print()
                    print(es.cluster.put_settings(body=setme, flat_settings=True, timeout="300s"))
                    print()
                except Exception:
                    error()
        else:
            try:
                print()
                print("Please enter setting and its value.")
                print()
            except Exception:
                error()

    # Elasticsearch indices
    def do_indices_settings(self, args):
        """
        Change specific index level settings in real time.
        $ indices_settings [index] [setting] [value] - change <index> static or dynamic <setting> to new <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter setting and its value.")
                print()
            else:
                try:
                    setme = '{{ "index": {{ "{0}" : {1} }} }}'.format(str(parms[1]), str(parms[2]))
                    print()
                    print("Setting: " + setme)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=setme))
                    print()
                except Exception:
                    error()
        else:
            try:
                print()
                print("Please enter setting and its value.")
                print()
            except Exception:
                error()

    def do_indices_refresh(self, args):
        """
        Explicitly refresh one or more index, making all operations performed since last
        refresh available for search.
        $ indices_refresh [index] - perform refresh on <index>.
        """
        if args:
            try:
                print()
                print(es.indices.refresh(index=args))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter the index name.")
            print()

    def complete_indices_refresh(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_flush(self, args):
        """
        Perform a normal flush, then add a generated unique marker (sync_id) to all shards.
        $ indices_flush [index] - preform a synced flush on <index>.
        """
        if args:
            try:
                print()
                print(es.indices.flush_synced(index=args))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter the index name.")
            print()

    def complete_indices_flush(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_create(self, args):
        """
        Create an empty index in Elasticsearch.
        $ indices_create [index] [number_of_shards] [number_of_replicas] - create <index>.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter index, number of shards and replicas.")
                print()
            else:
                try:
                    setme = '{{ "settings": {{ "index": {{ "number_of_shards": {0}, "number_of_replicas": {1} }} }} }}' \
                        .format(parms[1], parms[2])
                    print()
                    print(es.indices.create(index=parms[0], timeout="300s", wait_for_active_shards="all", body=setme))
                    print()
                except Exception:
                    error()
        else:
            try:
                print()
                print("Please enter index, number of shards and replicas.")
                print()
            except Exception:
                error()

    def do_indices_create_compressed(self, args):
        """
        Create an empty index in Elasticsearch with best compression.
        $ indices_create_compressed [index] - create <index> with best compression.
        """
        if args:
            try:
                print()
                print(es.indices.create(index=args, timeout="300s", wait_for_active_shards="all",
                                        body='{ "settings": { "index.codec": "best_compression" } }'))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter index name to create.")
            print()

    def do_indices_templates_delete(self, args):
        """
        Delete an index template by its name.
        $ indices_templates_delete [template] - delete <template>.
        """
        if args:
            try:
                print()
                print(es.indices.delete_template(name=args, master_timeout="300s"))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter template name to delete.")
            print()

    def do_indices_analyze_standard(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_standard you know for search
        """
        if args:
            try:
                print()
                print(json.dumps(es.indices.analyze(body='{{ "analyzer": "standard", "text": "{0}" }}'.format(args)),
                                 indent=4))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_analyze_simple(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_simple you know for search
        """
        if args:
            try:
                print()
                print(json.dumps(es.indices.analyze(body='{{ "analyzer": "simple", "text": "{0}" }}'.format(args)),
                                 indent=4))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_analyze_whitespace(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_whitespace you know for search
        """
        if args:
            try:
                print()
                print(json.dumps(es.indices.analyze(body='{{ "analyzer": "whitespace", "text": "{0}" }}'.format(args)),
                                 indent=4))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_analyze_stop(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_stop you know for search
        """
        if args:
            try:
                print()
                print(json.dumps(es.indices.analyze(body='{{ "analyzer": "stop", "text": "{0}" }}'.format(args)),
                                 indent=4))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_analyze_keyword(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_keyword you know for search
        """
        if args:
            try:
                print()
                print(json.dumps(es.indices.analyze(body='{{ "analyzer": "keyword", "text": "{0}" }}'.format(args)),
                                 indent=4))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_analyze_fingerprint(self, args):
        """
        Perform the analysis process on a text and return the tokens breakdown of the text.
        $ indices_analyze_fingerprint you know for search
        """
        if args:
            try:
                print()
                print(json.dumps(es.indices.analyze(body='{{ "analyzer": "fingerprint", "text": "{0}" }}'.format(args)),
                                 indent=4))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter text to analyze.")
            print()

    def do_indices_reindex(self, args):
        """
        Reindex all documents from one index to another.
        $ indices_reindex [index] [index]_old - copy documents from the <index> into the <index>_old.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please source and destination index.")
                print()
            else:
                try:
                    reindex = '{{ "source": {{ "index": "{0}" }}, "dest": {{ "index": "{1}" }} }}'.format(parms[0],
                                                                                                          parms[1])
                    print()
                    print("Executing: " + reindex)
                    print()
                    print(es.reindex(body=reindex, slices=8, wait_for_active_shards="all", wait_for_completion=False))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter source and destination index.")
            print()

    def do_indices_number_of_replicas(self, args):
        """
        Change the the number of replicas each primary shard has.
        $ indices_number_of_replicas [index] 0 - disable replication of <index>.
        $ indices_number_of_replicas [index] 1 - enable replication of <index>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and number of replicas.")
                print()
            else:
                try:
                    replicaset = '{{ "index": {{ "number_of_replicas": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + replicaset)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=replicaset))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index and number of replicas.")
            print()

    def do_indices_auto_expand_replicas(self, args):
        """
        Auto-expand the number of replicas based on number of available nodes. Set to a dash delimited
        lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all). Defaults to false.
        $ indices_auto_expand_replicas [index] [range] - change <index> auto-expand replicas to <range>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and number of auto-expand replicas.")
                print()
            else:
                try:
                    replicaset = '{{ "index": {{ "auto_expand_replicas": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + replicaset)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=replicaset))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index and number of auto-expand replicas.")
            print()

    def do_indices_refresh_interval(self, args):
        """
        How often to perform a refresh operation, which makes recent changes to the index visible to search.
        Defaults to 1s. Can be set to -1 to disable refresh.
        $ indices_refresh_interval [index] [value] - change <index> refresh interval to <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and refresh value in seconds.")
                print()
            else:
                try:
                    refreshset = '{{ "index": {{ "refresh_interval": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + refreshset)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=refreshset))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index and refresh value in seconds.")
            print()

    def do_indices_max_result_window(self, args):
        """
        The maximum value of 'from+size' for searches to this index. Defaults to 10.000. Search request take
        heap memory and time proportional to 'from+size' and this limits that memory.
        $ indices_max_result_window [index] [value] - change <index> max result window to <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and max result window value.")
                print()
            else:
                try:
                    maxwindow = '{{ "index": {{ "max_result_window": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + maxwindow)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=maxwindow))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index and max result window value.")
            print()

    def do_indices_max_rescore_window(self, args):
        """
        The maximum value of window_size for rescores in searches of this index. Defaults to
        'index.max_result_window' which defaults to 10.000. Search request take heap memory and time
        proportional to max(window_size, from+size) and this limits that memory.
        $ indices_max_rescore_window [index] [value] - change <index> max rescore window to <value>.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and max rescore window value.")
                print()
            else:
                try:
                    maxwindow = '{{ "index": {{ "max_rescore_window": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + maxwindow)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=maxwindow))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index and max rescore window value.")
            print()

    def do_indices_blocks_read_only(self, args):
        """
        Set to true to make the index and index metadata read only, false to allow writes and metadata changes.
        $ indices_blocks_read_only [index] [true|false] - make <index> na meta data read only or read/write.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and Boolen value.")
                print()
            else:
                try:
                    readonly = '{{ "index": {{ "blocks.read_only": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + readonly)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=readonly))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index and Boolen value.")
            print()

    def do_indices_blocks_read(self, args):
        """
        Set to true to disable read operations against the index.
        $ indices_blocks_read [index] [true|false] - make <index> write only.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and Boolen value.")
                print()
            else:
                try:
                    readonly = '{{ "index": {{ "blocks.read": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + readonly)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=readonly))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index and Boolen value.")
            print()

    def do_indices_blocks_write(self, args):
        """
        Set to true to disable write operations against the index.
        $ indices_blocks_write [index] [true|false] - make <index> read only.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and Boolen value.")
                print()
            else:
                try:
                    readonly = '{{ "index": {{ "blocks.write": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + readonly)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=readonly))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index and Boolen value.")
            print()

    def do_indices_blocks_metadata(self, args):
        """
        Set to true to disable index metadata reads and writes.
        $ indices_blocks_metadata [index] [true|false] - block <index> metadata for writes and reads.
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter index and Boolen value.")
                print()
            else:
                try:
                    readonly = '{{ "index": {{ "blocks.metadata": {0} }} }}'.format(parms[1])
                    print()
                    print("Setting: " + readonly)
                    print()
                    print(es.indices.put_settings(index=parms[0], body=readonly))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index and Boolen value.")
            print()

    def do_indices_search(self, args):
        """
        Execute a search query and get back search hits that match the query.
        $ indices_search [index] *:* 10 - return 10 hits of query <index> in the Lucene query string syntax.

        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter index, query and number of hits to return.")
                print()
            else:
                try:
                    less(json.dumps(es.search(index=parms[0], q=parms[1], size=parms[2]), indent=2))
                except Exception:
                    error()
        else:
            print()
            print("Please enter index, query and number of hits to return.")
            print()

    def do_indices_force_merge(self, args):
        """
        The force merge API allows to force merging of one or more indices through an API.
        The merge relates to the number of segments a Lucene index holds within each shard.
        The force merge operation allows to reduce the number of segments by merging them.
        $ indices_forcemerge [index] [number] - merge <index> to <number> of segments.
        """
        parms = args.split()
        if len(parms) != 2:
            print()
            print("Invalid number of arguments. Please provide index name nad number of segments.")
            print()
        else:
            try:
                print()
                print(es.indices.forcemerge(index=parms[0], max_num_segments=parms[1]))
                print()
            except Exception:
                error()

    def complete_indices_force_merge(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_force_merge_only_expunge_deletes(self, args):
        """
        Should the merge process only expunge segments with deletes in it. In Lucene, a document
        is not deleted from a segment, just marked as deleted. During a merge process of segments,
        a new segment is created that does not have those deletes. This command allows to only merge
        segments that have deletes.
        """
        parms = args.split()
        if len(parms) != 1:
            print()
            print("Invalid number of arguments. Please provide index name.")
            print()
        else:
            try:
                print()
                print(es.indices.forcemerge(index=parms[0], only_expunge_deletes=True))
                print()
            except Exception:
                error()

    def complete_indices_force_merge_only_expunge_deletes(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_aliases_delete(self, args):
        """
        Delete specific alias.
        $ indices_aliases_delete [alias] [index] - delete <alias> for <index> (use _all for all indices or aliases).
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter alias and index name.")
                print()
            else:
                try:
                    print()
                    print(es.indices.delete_alias(name=parms[0], index=parms[1]))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Invalid number of arguments. Please enter alias and index name.")
            print()

    def do_indices_aliases_create(self, args):
        """
        Create an alias for a specific index/indices.
        $ indices_aliases_create [alias] [index] - create <alias> for <index> (use _all for all indices).
        """
        if args:
            parms = args.split()
            if len(parms) != 2:
                print()
                print("Invalid number of arguments. Please enter alias and index name.")
                print()
            else:
                try:
                    print()
                    print(es.indices.put_alias(name=parms[0], index=parms[1]))
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Invalid number of arguments. Please enter alias and index name.")
            print()

    def do_indices_delete(self, args):
        """
        Delete an index in Elasticsearch.
        $ indices_delete [index] - delete the specified <index>.
        """
        if args:
            try:
                print()
                print(es.indices.delete(index=args, master_timeout="300s"))
                print()
            except Exception:
                error()
        else:
            print()
            print("Missing index or a comma-separated list of indices to delete.")
            print()

    def complete_indices_delete(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_close(self, args):
        """
        Close an index to remove it's overhead from the cluster.
        Closed index is blocked for read/write operations.
        $ indices_close [index] - close the specified <index>.
        """
        if args:
            try:
                print()
                print(es.indices.close(index=args, master_timeout="300s"))
                print()
            except Exception:
                error()
        else:
            print()
            print("Missing index or a comma-separated list of indices to close.")
            print()

    def complete_indices_close(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_open(self, args):
        """
        Open a closed index to make it available for search.
        $ indices_open [index] - open the specified <index>.
        """
        if args:
            try:
                print()
                print(es.indices.open(index=args, master_timeout="300s"))
                print()
            except Exception:
                error()
        else:
            print()
            print("Missing index or a comma-separated list of indices to open.")
            print()

    def complete_indices_open(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache(self, args):
        """
        Clear either all caches or specific cached associated with one or more indices.
        $ indices_clear_cache  [index] - clear cache of the specified <index>.
        $ indices_clear_cache - clear all caches (default)
        """
        if args:
            try:
                print()
                print(es.indices.clear_cache(index=args))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                print(es.indices.clear_cache())
                print()
            except Exception:
                error()

    def complete_indices_clear_cache(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_fielddata(self, args):
        """
        Clear field data.
        $ indices_clear_cache_fielddata [index] - clear field data of the specified <index>.
        $ indices_clear_cache_fielddata - clear field data of all indices (default).
        """
        if args:
            try:
                print()
                print(es.indices.clear_cache(index=args, fielddata=True))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                print(es.indices.clear_cache(fielddata=True))
                print()
            except Exception:
                error()

    def complete_indices_clear_cache_fielddata(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_query(self, args):
        """
        Clear query caches.
        $ indices_clear_cache_query [index] - clear query caches of the specified <index>.
        $ indices_clear_cache_query - clear query caches of all indices (default).
        """
        if args:
            try:
                print()
                print(es.indices.clear_cache(index=args, query=True))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                print(es.indices.clear_cache(query=True))
                print()
            except Exception:
                error()

    def complete_indices_clear_cache_query(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_recycler(self, args):
        """
        Clear the recycler cache.
        $ indices_clear_cache_recycler [index] - clear the recycler cache of the specified <index>.
        $ indices_clear_cache_recycler - clear the recycler cache of all indices (default).
        """
        if args:
            try:
                print()
                print(es.indices.clear_cache(index=args, recycler=True))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                print(es.indices.clear_cache(recycler=True))
                print()
            except Exception:
                error()

    def complete_indices_clear_cache_recycler(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_indices_clear_cache_request(self, args):
        """
        Clear the request cache.
        $ indices_clear_cache_request [index] - clear the request cache of the specified <index>.
        $ indices_clear_cache request - clear the request cache of all indices (default).
        """
        if args:
            try:
                print()
                print(es.indices.clear_cache(index=args, request=True))
                print()
            except Exception:
                error()
        else:
            try:
                print()
                print(es.indices.clear_cache(request=True))
                print()
            except Exception:
                error()

    def complete_indices_clear_cache_request(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    # Elasticsearch shards
    def do_shards_allocate_replica_dry_run(self, args):
        """
        Simulate allocate an unassigned replica shard to a node. Accepts the <index> for index name and
        <shard_number>, and <dest_node> to allocate the shard to.
        $ shards_allocate_replica_dry_run [index] [numer] [node] - simulate shard allocation.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter index_name shard_number and dest_node.")
                print()
            else:
                try:
                    alloc = '{{ "commands": [ {{ "allocate_replica": {{ "index": "{0}", "shard": {1}, "node": "{2}" ' \
                            '}} }} ] }}'.format(
                        str(parms[0]), str(parms[1]), str(parms[2]))
                    print()
                    print("Executing: " + alloc)
                    print()
                    pretty_print(es.cluster.reroute(body=alloc, dry_run=True, explain=True, metric="master_node"),
                                 indent=2)
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Invalid number of arguments. Please enter index_name shard_number and dest_node.")
            print()

    def complete_shards_allocate_replica_dry_run(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_allocate_replica(self, args):
        """
        Allocate an unassigned replica shard to a node. Accepts the <index> for index name and
        <shard_number>, and <dest_node> to allocate the shard to.
        $ shards_allocate_replica [index] [numer] [node] - allocate shard <number> of <index> to <node>.
        """
        if args:
            parms = args.split()
            if len(parms) != 3:
                print()
                print("Invalid number of arguments. Please enter index_name shard_number and dest_node.")
                print()
            else:
                try:
                    allocme = '{{ "commands": [ {{ "allocate_replica": {{ "index": "{0}", "shard": {1}, "node": "{2}" ' \
                              '}} }} ] }}'.format(
                        str(parms[0]), str(parms[1]), str(parms[2]))
                    print()
                    print("Executing: " + allocme)
                    print()
                    pretty_print(es.cluster.reroute(body=allocme, dry_run=False, explain=True, metric="master_node"),
                                 indent=2)
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Invalid number of arguments. Please enter index_name shard_number and dest_node.")
            print()

    def complete_shards_allocate_replica(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_move_dry_run(self, args):
        """
        Simulate move started shard from one node to another node.  Accepts <index> for index name and
        <shard_number>, <from_node> for the node to move the shard from, and <to_node> for the node to
        move the shard to.
        $ shards_move_dry_run [index] [number] [src_node] [dst_node] - simulate move shard <number> of <index>
          from <src_node> to <dst_node>.
        """
        if args:
            parms = args.split()
            if len(parms) != 4:
                print()
                print("Invalid number of arguments. Please enter index_name shard_number from_node to_node.")
                print()
            else:
                try:
                    moveme = '{{ "commands": [ {{ "move": {{ "index": "{0}", "shard": {1}, "from_node": "{2}",' \
                             '"to_node": "{3}" }} }} ] }}'.format(str(parms[0]), str(parms[1]), str(parms[2]),
                                                                  str(parms[3]))
                    print()
                    print("Executing: " + moveme)
                    print()
                    pretty_print(es.cluster.reroute(body=moveme, dry_run=True, explain=True, metric="master_node"),
                                 indent=2)
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index_name shard_number from_node to_node.")
            print()

    def complete_shards_move_dry_run(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    def do_shards_move(self, args):
        """
        Move started shard from one node to another node.  Accepts <index> for index name and
        <shard_number>, <from_node> for the node to move the shard from, and <to_node> for the
        node to move the shard to.
        $ shards_move [index] [number] [src_node] [dst_node] - move shard <number> of <index>
          from <src_node> to <dst_node>.
        """
        if args:
            parms = args.split()
            if len(parms) != 4:
                print()
                print("Invalid number of arguments. Please enter index_name shard_number from_node to_node.")
                print()
            else:
                try:
                    moveme = '{{ "commands": [ {{ "move": {{ "index": "{0}", "shard": {1}, "from_node": "{2}",' \
                             '"to_node": "{3}" }} }} ] }}'.format(str(parms[0]), str(parms[1]), str(parms[2]),
                                                                  str(parms[3]))
                    print()
                    print("Executing: " + moveme)
                    print()
                    pretty_print(es.cluster.reroute(body=moveme, explain=True, metric="master_node"), indent=2)
                    print()
                except Exception:
                    error()
        else:
            print()
            print("Please enter index_name shard_number from_node to_node.")
            print()

    def complete_shards_move(self, text, line, begidx, endidx):
        return [i for i in indexlist() if i.startswith(text)]

    # Elasticsearch nodes
    def do_nodes_tasks_cancel(self, args):
        """
        Cancel the task with specified task id (node_id:task_number).
        $ nodes_tasks_cancel [node_id:task_number] - cancel <task> on <node>.
        """

        if args:
            try:
                print()
                print(json.dumps(es.tasks.cancel(task_id=args), indent=4))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter node_id and task_number in format: node_id:task_number.")
            print()

    # Elasticsearch search
    def do_search_clear_scroll(self, args):
        """
        Clear the scroll request created by specifying the scroll parameter to search.
        $ search_clear_scroll [scroll_id] - clear the <scroll_id>.
        """
        if args:
            try:
                print()
                print(es.clear_scroll(scroll_id=args))
                print()
            except Exception:
                error()
        else:
            print()
            print("Please enter a comma-separated list of scroll IDs to clear.")
            print()


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("No elasticsearch server specified. Using default localhost.{0}".format(BColors.ENDC))
        if isopen("127.0.0.1", 9200):
            host = "127.0.0.1:9200"
        else:
            sys.exit(2)
    elif len(sys.argv) == 2:
        if check_hostname(sys.argv[1]):
            print(BColors.HEADER + "Connecting to elasticsearch server at address: {0:s}".format(sys.argv[1]) +
                  BColors.ENDC)
            if isopen(sys.argv[1], 9200):
                host = sys.argv[1] + ":9200"
            else:
                sys.exit(2)
        elif check_ip(sys.argv[1]):
            print(BColors.HEADER + "Connecting to elasticsearch server at address: {0:s}".format(sys.argv[1]) +
                  BColors.ENDC)
            if isopen(sys.argv[1], 9200):
                host = sys.argv[1] + ":9200"
            else:
                sys.exit(2)
        else:
            print("Wrong DNS or IP elasticsearch node address.")
    elif len(sys.argv) == 3:
        if check_hostname(sys.argv[1]):
            print(BColors.HEADER + "Connecting to elasticsearch server at address: {0:s}:{1:s}".format(sys.argv[1],
                                                                                                       sys.argv[2]) +
                  BColors.ENDC)
            if isopen(sys.argv[1], int(sys.argv[2])):
                host = sys.argv[1] + ":" + sys.argv[2]
            else:
                sys.exit(2)
        elif check_ip(sys.argv[1]):
            print(BColors.HEADER + "Connecting to elasticsearch server at adress: {0:s}:{1:s}".format(sys.argv[1],
                                                                                                      sys.argv[2]) +
                  BColors.ENDC)
            if isopen(sys.argv[1], int(sys.argv[2])):
                host = sys.argv[1] + ":" + sys.argv[2]
            else:
                sys.exit(2)
        else:
            print("Wrong DNS or IP elasticsearch node address.")
    else:
        sys.exit("Usage: {0} [ES master IP/DNS address] [port]".format(sys.argv[0]))
    try:
        if "libedit" in readline.__doc__:
            readline.parse_and_bind("bind ^I rl_complete")
        else:
            readline.parse_and_bind("tab: complete")
        if "ESAUTH" in os.environ:
            login = input("Please enter login name: ")
            psswd = getpass.getpass("Password: ")
            sslca = input("Please enter CA file path (or leave blank): ")
            if sslca == "":
                sslca = None
            sslcrt = input("Please enter CRT file path (or leave blank): ")
            if sslcrt == "":
                sslcrt = None
            sslkey = input("Please enter KEY file path (or leave blank): ")
            if sslkey == "":
                sslkey = None
            auth = "{0}:{1}".format(login, psswd)
            host = "https://{0}@{1}".format(auth, host)
            if sslca is None:
                context = elasticsearch.connection.create_ssl_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                warnings.filterwarnings("ignore", message="Unverified HTTPS request")
                warnings.filterwarnings("ignore", message="When using `ssl_context`")
                es = elasticsearch.Elasticsearch([host], timeout=300, sniff_on_start=False,
                                                 sniff_on_connection_fail=False,
                                                 sniffer_timeout=None, retry_on_timeout=True, retry_on_status=True,
                                                 max_retries=99, ca_certs=sslca, client_cert=sslcrt, client_key=sslkey,
                                                 ssl_version=ssl.PROTOCOL_TLSv1_2, verify_certs=False,
                                                 ssl_show_warn=False,
                                                 ssl_context=context)
            else:
                es = elasticsearch.Elasticsearch([host], timeout=300, sniff_on_start=False,
                                                 sniff_on_connection_fail=False,
                                                 sniffer_timeout=None, retry_on_timeout=True, retry_on_status=True,
                                                 max_retries=99, ca_certs=sslca, client_cert=sslcrt, client_key=sslkey,
                                                 ssl_version=ssl.PROTOCOL_TLSv1_2)
        else:
            host = "http://{0}".format(host)
            es = elasticsearch.Elasticsearch([host], timeout=300, sniff_on_start=False, sniff_on_connection_fail=False,
                                             sniffer_timeout=None, retry_on_timeout=True, retry_on_status=True,
                                             max_retries=99)

        # EShell directory.
        if not os.path.exists(os.path.expanduser('~/.eshell')):
            os.makedirs(os.path.expanduser('~/.eshell'), exist_ok=True)
        # Session history.
        history_file = os.path.expanduser('~/.eshell/history')
        history_size = 1000
        if not os.path.exists(history_file):
            f = open(history_file, "w+")
            f.write("_HiStOrY_V2_\n\n")
            f.close()
        readline.set_history_length(1000)
        readline.read_history_file(history_file)
        # Session logging.
        logfile = os.path.expanduser('~/.eshell/es.log')

        if os.path.isfile(logfile):
            size = os.path.getsize(logfile)
            if size >= 104857600:
                logging.handlers.RotatingFileHandler(filename=logfile, backupCount=10).doRollover()

        request_logger = logging.getLogger('urllib3')
        request_logger.setLevel(logging.DEBUG)
        request_file = logging.FileHandler(logfile)
        request_file.setLevel(logging.DEBUG)
        request_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        request_file.setFormatter(request_formatter)
        request_logger.addHandler(request_file)
        response_logger = logging.getLogger('elasticsearch.trace')
        response_logger.setLevel(logging.DEBUG)
        response_file = logging.FileHandler(logfile)
        response_file.setLevel(logging.DEBUG)
        response_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        response_file.setFormatter(response_formatter)
        response_logger.addHandler(response_file)
        request_logger.info("### STARTING ELASTICSEARCH SHELL SESSION TO: {0:s}...".format(sys.argv[1]))
        esconsole = ES()
        esconsole.cmdloop()
        atexit.register(readline.write_history_file, history_file)
        request_logger.info("### CLOSING ELASTICSEARCH SHELL SESSION TO: {0:s}...".format(sys.argv[1]))
    except KeyboardInterrupt:
        print("Exiting...")
        sys.exit(0)
    except Exception:
        error()
